

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>valis.registration &mdash; valis &#34;1.0.0rc5&#34;
 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: black" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/valis_logo_black_no_bg.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../registration.html">Registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../slide_io.html">Slide I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preprocessing.html">Image pre-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature_detectors.html">Feature detectors and descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature_matcher.html">Feature matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../affine_optimizer.html">Affine optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../non_rigid_registrars.html">Non-rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../serial_rigid.html">Serial rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../serial_non_rigid.html">Serial non-rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../viz.html">Visualization</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">valis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>valis.registration</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for valis.registration</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Virtual Alignment of pathoLogy Image Series</span>

<span class="sd">Implements the registration pipeline described in</span>
<span class="sd">&quot;VALIS: Virtual Alignment of pathoLogy Image Series&quot; by Gatenbee et al.</span>
<span class="sd">This pipeline will read images and whole slide images (WSI) using pyvips,</span>
<span class="sd">bioformats, or openslide, and so should work with a wide variety of formats.</span>
<span class="sd">VALIS can perform both rigid and non-rigid registration. The registered slides</span>
<span class="sd">can be saved as ome.tiff slides that can be used in downstream analyses. The</span>
<span class="sd">ome.tiff format is opensource and widely supported, being readable in several</span>
<span class="sd">different programming languages (Python, Java, Matlab, etc...) and software,</span>
<span class="sd">such as QuPath or HALO.</span>

<span class="sd">The pipeline is fully automated and goes as follows:</span>

<span class="sd">*. Images/slides are converted to numpy arrays. As WSI are often</span>
<span class="sd">too large to fit into memory, these images are usually lower resolution</span>
<span class="sd">images from different pyramid levels.</span>

<span class="sd">*. Images are processed to single channel images. They are then</span>
<span class="sd">normalized to make them look as similar as possible.</span>

<span class="sd">*. Image features are detected and then matched between all pairs of image.</span>

<span class="sd">*. If the order of images is unknown, they will be optimally ordered</span>
<span class="sd">based on their feature similarity</span>

<span class="sd">*. Rigid registration is performed serially, with each image being</span>
<span class="sd">rigidly aligned to the previous image in the stack. VALIS uses feature</span>
<span class="sd">detection to match and align images, but one can optionally perform</span>
<span class="sd">a final step that maximizes the mutual information betweeen each</span>
<span class="sd">pair of images.</span>

<span class="sd">* Non-rigid registration is then performed either by 1) aliging each image</span>
<span class="sd">towards the center of the stack, composing the deformation fields</span>
<span class="sd">along the way, or 2) using groupwise registration that non-rigidly aligns</span>
<span class="sd">the images to a common frame of reference.</span>

<span class="sd">* Error is measured by calculating the distance between registered</span>
<span class="sd">matched features.</span>

<span class="sd">The transformations found by VALIS can then be used to warp the full</span>
<span class="sd">resolution slides. It is also possible to merge non-RGB registered slides</span>
<span class="sd">to create a highly multiplexed image. These aligned and/or merged slides</span>
<span class="sd">can then be saved as ome.tiff images using pyvips.</span>

<span class="sd">In addition to warping images and slides, VALIS can also warp point data,</span>
<span class="sd">such as cell centoids or ROI coordinates.</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">In this example, the slides that need to be aligned are located in</span>
<span class="sd">&quot;../resources/slides/ihc_mrxs&quot;. Registration results will be saved</span>
<span class="sd">in  &quot;./slide_registration_example&quot;, in which will be 6 folders:</span>

<span class="sd">1. *data* contains 2 files:</span>
<span class="sd">    * a summary spreadsheet of the alignment results, such</span>
<span class="sd">    as the registration error between each pair of slides, their</span>
<span class="sd">    dimensions, physical units, etc...</span>

<span class="sd">    * a pickled version of the registrar. This can be reloaded</span>
<span class="sd">    (unpickled) and used later. For example, one could perform</span>
<span class="sd">    the registration locally, but then use the pickled object</span>
<span class="sd">    to warp and save the slides on an HPC. Or, one could perform</span>
<span class="sd">    the registration and use the registrar later to warp</span>
<span class="sd">    points in the slide.</span>

<span class="sd">2. *overlaps* contains thumbnails showing the how the images</span>
<span class="sd">    would look if stacked without being registered, how they</span>
<span class="sd">    look after rigid registration, and how they would look</span>
<span class="sd">    after non-rigid registration.</span>

<span class="sd">3. *rigid_registration* shows thumbnails of how each image</span>
<span class="sd">    looks after performing rigid registration.</span>

<span class="sd">4. *non_rigid_registration* shows thumbnaials of how each</span>
<span class="sd">    image looks after non-rigid registration.</span>

<span class="sd">5. *deformation_fields* contains images showing what the</span>
<span class="sd">    non-rigid deformation would do to a triangular mesh.</span>
<span class="sd">    These can be used to get a better sense of how the</span>
<span class="sd">    images were altered by non-rigid warping</span>

<span class="sd">6. *processed* shows thumnails of the processed images.</span>
<span class="sd">    This are thumbnails of the images that are actually</span>
<span class="sd">    used to perform the registration. The pre-processing</span>
<span class="sd">    and normalization methods should try to make these</span>
<span class="sd">    images look as similar as possible.</span>

<span class="sd">After registraation is complete, one can view the</span>
<span class="sd">results to determine if they are acceptable. If they</span>
<span class="sd">are, then one can warp and save all of the slides.</span>

<span class="sd">&gt;&gt;&gt; from valis import registration</span>
<span class="sd">&gt;&gt;&gt; slide_src_dir = &quot;/path/to/slides&quot;</span>
<span class="sd">&gt;&gt;&gt; results_dst_dir = &quot;./slide_registration_example&quot;</span>
<span class="sd">&gt;&gt;&gt; registered_slide_dst_dir = &quot;./slide_registration_example/registered_slides&quot;</span>

<span class="sd">Perform registration</span>

<span class="sd">&gt;&gt;&gt; registrar = registration.Valis(slide_src_dir, results_dst_dir)</span>
<span class="sd">&gt;&gt;&gt; rigid_registrar, non_rigid_registrar, error_df = registrar.register()</span>

<span class="sd">View results in &quot;./slide_registration_example&quot;.</span>

<span class="sd">If they look good, warp and save the slides as ome.tiff</span>

<span class="sd">&gt;&gt;&gt; registrar.warp_and_save_slides(registered_slide_dst_dir)</span>

<span class="sd">Don&#39;t forget to kill the JVM</span>

<span class="sd">&gt;&gt;&gt; registration.kill_jvm()</span>


<span class="sd">This next example shows how to align a series of CyCIF images and then</span>
<span class="sd">merge them into a single ome.tiff image</span>

<span class="sd">&gt;&gt;&gt; from valis import registration</span>
<span class="sd">&gt;&gt;&gt; slide_src_dir = &quot;/path/to/slides&quot;</span>
<span class="sd">&gt;&gt;&gt; results_dst_dir = &quot;./slide_merging_example&quot;</span>
<span class="sd">&gt;&gt;&gt; merged_slide_dst_f = &quot;./slide_merging_example/merged_slides.ome.tiff&quot;</span>

<span class="sd">Create a Valis object and use it to register the slides</span>

<span class="sd">&gt;&gt;&gt; registrar = registration.Valis(slide_src_dir, results_dst_dir)</span>
<span class="sd">&gt;&gt;&gt; rigid_registrar, non_rigid_registrar, error_df = registrar.register()</span>

<span class="sd">Create function to get marker names from each slides&#39; filename</span>

<span class="sd">&gt;&gt;&gt; def cnames_from_filename(src_f):</span>
<span class="sd">...     f = valtils.get_name(src_f)</span>
<span class="sd">...     return [&quot;DAPI&quot;] + f.split(&quot; &quot;)[1:4]</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; channel_name_dict = {f:cnames_from_filename(f) for f in  registrar.original_img_list}</span>
<span class="sd">&gt;&gt;&gt; merged_img, channel_names, ome_xml = registrar.warp_and_merge_slides(merged_slide_dst_f, channel_name_dict=channel_name_dict)</span>

<span class="sd">View ome.tiff, located at merged_slide_dst_f</span>

<span class="sd">VALIS can also be used to warp point data. Here it will register 2 TMA cores and then</span>
<span class="sd">warp cell positions located in a separate .csv</span>

<span class="sd">&gt;&gt;&gt; import numpy as np</span>
<span class="sd">&gt;&gt;&gt; import pandas as pd</span>
<span class="sd">&gt;&gt;&gt; import pathlib</span>
<span class="sd">&gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">&gt;&gt;&gt; slide_src_dir = &quot;path/to/slides&quot;</span>
<span class="sd">&gt;&gt;&gt; point_data_dir = &quot;path/to/cell_positions&quot;</span>
<span class="sd">&gt;&gt;&gt; results_dst_dir = &quot;./point_warping_example&quot;</span>

<span class="sd">Create a Valis object and use it to register the slides in slide_src_dir</span>

<span class="sd">&gt;&gt;&gt; registrar = registration.Valis(slide_src_dir, results_dst_dir)</span>
<span class="sd">&gt;&gt;&gt; rigid_registrar, non_rigid_registrar, error_df = registrar.register()</span>

<span class="sd">Warp points, which are located in csv files</span>

<span class="sd">&gt;&gt;&gt; point_data_list = list(pathlib.Path(point_data_dir).rglob(&quot;*.csv&quot;))</span>
<span class="sd">&gt;&gt;&gt; for f in point_data_list:</span>
<span class="sd">...     # Get Slide associated with the slide from which the point data originated</span>
<span class="sd">...     # Point data and image have similar file names</span>
<span class="sd">...     fname = os.path.split(f)[1]</span>
<span class="sd">...     corresponding_img = fname.split(&quot;.tif&quot;)[0]</span>
<span class="sd">...     slide_obj = registrar.get_slide(corresponding_img)</span>
<span class="sd">...</span>
<span class="sd">...     # Read data and calculate cell centroids (x, y)</span>
<span class="sd">...     points_df = pd.read_csv(f)</span>
<span class="sd">...     x = np.mean(points_df[[&quot;XMin&quot;, &quot;XMax&quot;]], axis=1).values</span>
<span class="sd">...     y = np.mean(points_df[[&quot;YMin&quot;, &quot;YMax&quot;]], axis=1).values</span>
<span class="sd">...     xy = np.dstack([x, y])[0]</span>
<span class="sd">...</span>
<span class="sd">...     # Use Slide to warp the coordinates</span>
<span class="sd">...     warped_xy = slide_obj.warp_xy(xy)</span>
<span class="sd">...     # Update dataframe with registered cell centroids</span>
<span class="sd">...     points_df[[&quot;registered_x&quot;, &quot;registered_y&quot;]] = warped_xy</span>
<span class="sd">...</span>
<span class="sd">...     # Save updated dataframe</span>
<span class="sd">...     pt_f_out = os.path.split(f)[1].replace(&quot;.csv&quot;, &quot;_registered.csv&quot;)</span>
<span class="sd">...     full_pt_f_out = os.path.join(results_dst_dir, pt_f_out)</span>
<span class="sd">...     points_df.to_csv(full_pt_f_out, index=False)</span>
<span class="sd">&gt;&gt;&gt; valis.kill_jvm() # Kill the JVM</span>

<span class="sd">In most cases the default paramters work well. However, one may wish to try</span>
<span class="sd">non-default parameters. In this case, we will use KAZE for</span>
<span class="sd">feature detection and description, and SimpleElastix for non-rigid warping.</span>

<span class="sd">&gt;&gt;&gt; from valis import feature_detectors, non_rigid_registrars</span>
<span class="sd">&gt;&gt;&gt; feature_detector = feature_detectors.KazeFD</span>
<span class="sd">&gt;&gt;&gt; non_rigid_registrar = non_rigid_registrars.SimpleElastixWarper</span>
<span class="sd">&gt;&gt;&gt; slide_src_dir = data.ihc2_src_dir</span>
<span class="sd">&gt;&gt;&gt; registrar = registration.Valis(slide_src_dir, results_dst_dir,</span>
<span class="sd">...                         feature_detector_cls=feature_detector,</span>
<span class="sd">...                         non_rigid_registrar_cls=non_rigid_registrar)</span>

<span class="sd">rigid_registrar, non_rigid_registrar, error_df = registrar.register()</span>

<span class="sd">Finlly, VALIS can also be used to convert slides to ome.tiff. Here</span>
<span class="sd">is an example of converting a large tiff to ome.tiff. Note that</span>
<span class="sd">bioformats does not seem to read this file correctly, so it is a</span>
<span class="sd">good case where conversion to ome.tiff mmight be needed. Takes</span>
<span class="sd">approximately 5 minutes.</span>

<span class="sd">&gt;&gt;&gt; from valis import slide_io</span>
<span class="sd">&gt;&gt;&gt; slide_src_f = &quot;path/to/slide&quot;</span>
<span class="sd">&gt;&gt;&gt; converted_slide_f = &quot;./slide_conversion_example/Beg_P1_48_C1D15_06S17081023.ome.tiff&quot;</span>
<span class="sd">&gt;&gt;&gt; slide_io.convert_to_ome_tiff(slide_src_f, converted_slide_f, level=0, perceputally_uniform_channel_colors=True)</span>

<span class="sd">After access to slides is no longer needed, be sure to kill the JVM</span>

<span class="sd">&gt;&gt;&gt; registration.kill_jvm()</span>

<span class="sd">Attributes</span>
<span class="sd">----------</span>
<span class="sd">CONVERTED_IMG_DIR : str</span>
<span class="sd">    Where thumnails of the converted images will be saved</span>

<span class="sd">PROCESSED_IMG_DIR : str</span>
<span class="sd">    Where thumnails of the processed images will be saved</span>

<span class="sd">RIGID_REG_IMG_DIR : str</span>
<span class="sd">    Where thumnails of the rigidly aligned images will be saved</span>

<span class="sd">NON_RIGID_REG_IMG_DIR : str</span>
<span class="sd">    Where thumnails of the non-rigidly aligned images will be saved</span>

<span class="sd">DEFORMATION_FIELD_IMG_DIR : str</span>
<span class="sd">    Where thumnails of the non-rigid deformation fields will be saved</span>

<span class="sd">OVERLAP_IMG_DIR : str</span>
<span class="sd">    Where thumnails of the image overlaps will be saved</span>

<span class="sd">REG_RESULTS_DATA_DIR : str</span>
<span class="sd">    Where the summary and pickled Valis object will be saved</span>

<span class="sd">DEFAULT_BRIGHTFIELD_CLASS : preprocessing.ImageProcesser</span>
<span class="sd">    Default ImageProcesser class used to process brightfield images</span>

<span class="sd">DEFAULT_BRIGHTFIELD_PROCESSING_ARGS : dict</span>
<span class="sd">    Dictionary of keyward arguments passed to DEFAULT_BRIGHTFIELD_CLASS.process_image()</span>

<span class="sd">DEFAULT_FLOURESCENCE_CLASS : preprocessing.ImageProcesser</span>
<span class="sd">    Default ImageProcesser class used to process immunofluorescence images</span>

<span class="sd">DEFAULT_FLOURESCENCE_PROCESSING_ARGS : dict</span>
<span class="sd">    Dictionary of keyward arguments passed to DEFAULT_FLOURESCENCE_PROCESSING_ARGS.process_image()</span>

<span class="sd">DEFAULT_NORM_METHOD : str</span>
<span class="sd">    Default image normalization method</span>

<span class="sd">DEFAULT_FD : feature_detectors.FeatureDD</span>
<span class="sd">    Default feature detector class</span>

<span class="sd">DEFAULT_TRANSFORM_CLASS : skimage.transform.GeometricTransform</span>
<span class="sd">    Default rigid transformer class</span>

<span class="sd">DEFAULT_MATCH_FILTER : str</span>
<span class="sd">    Default match filtering method to use</span>

<span class="sd">DEFAULT_SIMILARITY_METRIC : str</span>
<span class="sd">    Default similarity metric used to compare images</span>

<span class="sd">DEFAULT_AFFINE_OPTIMIZER_CLASS : affine_optimizer.AffineOptimizer</span>
<span class="sd">    Default affine optimaer to use. If None, affine optimization will not be performed</span>

<span class="sd">DEFAULT_NON_RIGID_CLASS : non_rigid_registrars.NonRigidRegistrar</span>
<span class="sd">    Default non-rigid registrar. If None, non-rigid registration will not be performed</span>

<span class="sd">DEFAULT_NON_RIGID_KWARGS : dict</span>
<span class="sd">    Default parameters used to intialize DEFAULT_NON_RIGID_CLASS</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">io</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">exposure</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">tqdm</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">colour</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">feature_matcher</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">serial_rigid</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">feature_detectors</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">non_rigid_registrars</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">valtils</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">preprocessing</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">slide_tools</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">slide_io</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">viz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">warp_tools</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">serial_non_rigid</span>

<span class="c1"># Destination directories #</span>
<span class="n">CONVERTED_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;images&quot;</span>
<span class="n">PROCESSED_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;processed&quot;</span>
<span class="n">RIGID_REG_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;rigid_registration&quot;</span>
<span class="n">NON_RIGID_REG_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;non_rigid_registration&quot;</span>
<span class="n">DEFORMATION_FIELD_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;deformation_fields&quot;</span>
<span class="n">OVERLAP_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;overlaps&quot;</span>
<span class="n">REG_RESULTS_DATA_DIR</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>

<span class="c1"># Default image processing #</span>
<span class="n">DEFAULT_BRIGHTFIELD_CLASS</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">ColorfulStandardizer</span>
<span class="n">DEFAULT_BRIGHTFIELD_PROCESSING_ARGS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">DEFAULT_COLOR_STD_C</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
<span class="n">DEFAULT_FLOURESCENCE_CLASS</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">ChannelGetter</span>
<span class="n">DEFAULT_FLOURESCENCE_PROCESSING_ARGS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;channel&quot;</span><span class="p">:</span> <span class="s2">&quot;dapi&quot;</span><span class="p">,</span> <span class="s2">&quot;adaptive_eq&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
<span class="n">DEFAULT_NORM_METHOD</span> <span class="o">=</span> <span class="s2">&quot;img_stats&quot;</span>

<span class="c1"># Default rigid registration parameters #</span>
<span class="n">DEFAULT_FD</span> <span class="o">=</span> <span class="n">feature_detectors</span><span class="o">.</span><span class="n">VggFD</span>
<span class="n">DEFAULT_TRANSFORM_CLASS</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">SimilarityTransform</span>
<span class="n">DEFAULT_MATCH_FILTER</span> <span class="o">=</span> <span class="n">feature_matcher</span><span class="o">.</span><span class="n">RANSAC_NAME</span>
<span class="n">DEFAULT_SIMILARITY_METRIC</span> <span class="o">=</span> <span class="s2">&quot;n_matches&quot;</span>
<span class="n">DEFAULT_AFFINE_OPTIMIZER_CLASS</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">DEFAULT_MAX_PROCESSED_IMG_SIZE</span> <span class="o">=</span> <span class="mi">850</span>
<span class="n">DEFAULT_MAX_IMG_DIM</span> <span class="o">=</span> <span class="mi">850</span>
<span class="n">DEFAULT_THUMBNAIL_SIZE</span> <span class="o">=</span> <span class="mi">500</span>

<span class="c1"># Rigid registration kwarg keys #</span>
<span class="n">AFFINE_OPTIMIZER_KEY</span> <span class="o">=</span> <span class="s2">&quot;affine_optimizer&quot;</span>
<span class="n">TRANSFORMER_KEY</span> <span class="o">=</span> <span class="s2">&quot;transformer&quot;</span>
<span class="n">SIM_METRIC_KEY</span> <span class="o">=</span> <span class="s2">&quot;similarity_metric&quot;</span>
<span class="n">FD_KEY</span> <span class="o">=</span> <span class="s2">&quot;feature_detector&quot;</span>
<span class="n">MATCHER_KEY</span> <span class="o">=</span> <span class="s2">&quot;matcher&quot;</span>
<span class="n">NAME_KEY</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span>
<span class="n">IMAGES_ORDERD_KEY</span> <span class="o">=</span> <span class="s2">&quot;imgs_ordered&quot;</span>
<span class="n">REF_IMG_KEY</span> <span class="o">=</span> <span class="s2">&quot;reference_img_f&quot;</span>
<span class="n">QT_EMMITER_KEY</span> <span class="o">=</span> <span class="s2">&quot;qt_emitter&quot;</span>

<span class="c1"># Rigid registration kwarg keys #</span>
<span class="n">NON_RIGID_REG_CLASS_KEY</span> <span class="o">=</span> <span class="s2">&quot;non_rigid_reg_class&quot;</span>
<span class="n">NON_RIGID_REG_PARAMS_KEY</span> <span class="o">=</span> <span class="s2">&quot;non_rigid_reg_params&quot;</span>
<span class="n">NON_RIGID_USE_XY_KEY</span> <span class="o">=</span> <span class="s2">&quot;moving_to_fixed_xy&quot;</span>

<span class="c1"># Default non-rigid registration parameters #</span>
<span class="n">DEFAULT_NON_RIGID_CLASS</span> <span class="o">=</span> <span class="n">non_rigid_registrars</span><span class="o">.</span><span class="n">OpticalFlowWarper</span>
<span class="n">DEFAULT_NON_RIGID_KWARGS</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># Cropping options</span>
<span class="n">CROP_OVERLAP</span> <span class="o">=</span> <span class="s2">&quot;overlap&quot;</span>
<span class="n">CROP_REF</span> <span class="o">=</span> <span class="s2">&quot;reference&quot;</span>
<span class="n">CROP_NONE</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>

<span class="k">def</span> <span class="nf">init_jvm</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Initialize JVM for BioFormats</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">slide_io</span><span class="o">.</span><span class="n">init_jvm</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">kill_jvm</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Kill JVM for BioFormats</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">slide_io</span><span class="o">.</span><span class="n">kill_jvm</span><span class="p">()</span>


<div class="viewcode-block" id="Slide"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide">[docs]</a><span class="k">class</span> <span class="nc">Slide</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stores registration info and warps slides/points</span>

<span class="sd">    `Slide` is a class that stores registration parameters</span>
<span class="sd">    and other metadata about a slide. Once registration has been</span>
<span class="sd">    completed, `Slide` is also able warp the slide and/or points</span>
<span class="sd">    using the same registration parameters. Warped slides can be saved</span>
<span class="sd">    as ome.tiff images with valid ome-xml.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    src_f : str</span>
<span class="sd">        Path to slide.</span>

<span class="sd">    image: ndarray</span>
<span class="sd">        Image to registered. Taken from a level in the image pyramid.</span>
<span class="sd">        However, image may be resized to fit within the `max_image_dim_px`</span>
<span class="sd">        argument specified when creating a `Valis` object.</span>

<span class="sd">    val_obj : Valis</span>
<span class="sd">        The &quot;parent&quot; object that registers all of the slide.</span>

<span class="sd">    reader : SlideReader</span>
<span class="sd">        Object that can read slides and collect metadata.</span>

<span class="sd">    original_xml : str</span>
<span class="sd">        Xml string created by bio-formats</span>

<span class="sd">    img_type : str</span>
<span class="sd">        Whether the image is &quot;brightfield&quot; or &quot;fluorescence&quot;</span>

<span class="sd">    is_rgb : bool</span>
<span class="sd">        Whether or not the slide is RGB.</span>

<span class="sd">    slide_shape_rc : tuple of int</span>
<span class="sd">        Dimensions of the largest resolution in the slide, in the form</span>
<span class="sd">        of (row, col).</span>

<span class="sd">    series : int</span>
<span class="sd">        Slide series to be read</span>

<span class="sd">    slide_dimensions_wh : ndarray</span>
<span class="sd">        Dimensions of all images in the pyramid (width, height).</span>

<span class="sd">    resolution : float</span>
<span class="sd">        Physical size of each pixel.</span>

<span class="sd">    units : str</span>
<span class="sd">        Physical unit of each pixel.</span>

<span class="sd">    name : str</span>
<span class="sd">        Name of the image. Usually `img_f` but with the extension removed.</span>

<span class="sd">    stack_idx : int</span>
<span class="sd">        Position of image in sorted Z-stack</span>

<span class="sd">    processed_img_f : str</span>
<span class="sd">        Path to thumbnail of the processed `image`.</span>

<span class="sd">    rigid_reg_img_f : str</span>
<span class="sd">        Path to thumbnail of rigidly aligned `image`.</span>

<span class="sd">    non_rigid_reg_img_f : str</span>
<span class="sd">        Path to thumbnail of non-rigidly aligned `image`.</span>

<span class="sd">    processed_img_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of the processed image used to find the</span>
<span class="sd">        transformation parameters. Maximum dimension will be less or</span>
<span class="sd">        equal to the `max_processed_image_dim_px` specified when</span>
<span class="sd">        creating a `Valis` object. As such, this may be smaller than</span>
<span class="sd">        the image&#39;s shape.</span>

<span class="sd">    aligned_slide_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of aligned slide, based on the dimensions in the 0th</span>
<span class="sd">        level of they pyramid. In</span>

<span class="sd">    reg_img_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of the registered image</span>

<span class="sd">    M : ndarray</span>
<span class="sd">        Rigid transformation matrix that aligns `image` to the previous</span>
<span class="sd">        image in the stack. Found using the processed copy of `image`.</span>

<span class="sd">    bk_dxdy : ndarray</span>
<span class="sd">        (2, N, M) numpy array of pixel displacements in</span>
<span class="sd">        the x and y directions. dx = bk_dxdy[0], and dy=bk_dxdy[1]. Used</span>
<span class="sd">        to warp images. Found using the rigidly aligned version of the</span>
<span class="sd">        processed image.</span>

<span class="sd">    fwd_dxdy : ndarray</span>
<span class="sd">        Inverse of `bk_dxdy`. Used to warp points.</span>

<span class="sd">    fixed_slide : Slide</span>
<span class="sd">        Slide object to which this one was aligned.</span>

<span class="sd">    xy_matched_to_prev : ndarray</span>
<span class="sd">        Coordinates (x, y) of features in `image` that had matches in the</span>
<span class="sd">        previous image. Will have shape (N, 2)</span>

<span class="sd">    xy_in_prev : ndarray</span>
<span class="sd">        Coordinates (x, y) of features in the previous that had matches</span>
<span class="sd">        to those in `image`. Will have shape (N, 2)</span>

<span class="sd">    xy_matched_to_prev_in_bbox : ndarray</span>
<span class="sd">        Subset of `xy_matched_to_prev` that were within `overlap_mask_bbox_xywh`.</span>
<span class="sd">        Will either have shape (N, 2) or (M, 2), with M &lt; N.</span>

<span class="sd">    xy_in_prev_in_bbox : ndarray</span>
<span class="sd">        Subset of `xy_in_prev` that were within `overlap_mask_bbox_xywh`.</span>
<span class="sd">        Will either have shape (N, 2) or (M, 2), with M &lt; N.</span>

<span class="sd">    crop : str</span>
<span class="sd">        Crop method</span>

<span class="sd">    bg_px_pos_rc : tuple</span>
<span class="sd">        Position of pixel that has the background color</span>

<span class="sd">    bg_color : list, optional</span>
<span class="sd">        Color of background pixels</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Slide.__init__"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_f</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">val_obj</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_f : str</span>
<span class="sd">            Path to slide.</span>

<span class="sd">        image: ndarray</span>
<span class="sd">            Image to registered. Taken from a level in the image pyramid.</span>
<span class="sd">            However, image may be resized to fit within the `max_image_dim_px`</span>
<span class="sd">            argument specified when creating a `Valis` object.</span>

<span class="sd">        val_obj : Valis</span>
<span class="sd">            The &quot;parent&quot; object that registers all of the slide.</span>

<span class="sd">        reader : SlideReader</span>
<span class="sd">            Object that can read slides and collect metadata.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">src_f</span> <span class="o">=</span> <span class="n">src_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span> <span class="o">=</span> <span class="n">val_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span> <span class="o">=</span> <span class="n">reader</span>

        <span class="c1"># Metadata #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_type</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">guess_image_type</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_rgb</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">is_rgb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slide_shape_rc</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">slide_dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slide_dimensions_wh</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">slide_dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">pixel_physical_size_xyu</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">pixel_physical_size_xyu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_xml</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">original_xml</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">src_f</span><span class="p">)</span>

        <span class="c1"># To be filled in during registration #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_img_f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_img_f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_img_f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_slide</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_matched_to_prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_in_prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_matched_to_prev_in_bbox</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_in_prev_in_bbox</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg_px_pos_rc</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Slide.slide2image"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.slide2image">[docs]</a>    <span class="k">def</span> <span class="nf">slide2image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xywh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert slide to image</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        level : int</span>
<span class="sd">            Pyramid level</span>

<span class="sd">        series : int, optional</span>
<span class="sd">            Series number. Defaults to 0</span>

<span class="sd">        xywh : tuple of int, optional</span>
<span class="sd">            The region to be sliced from the slide. If None,</span>
<span class="sd">            then the entire slide will be converted. Otherwise</span>
<span class="sd">            xywh is the (top left x, top left y, width, height) of</span>
<span class="sd">            the region to be sliced.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        img : ndarray</span>
<span class="sd">            An image of the slide or the region defined by xywh</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">slide2image</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span> <span class="n">xywh</span><span class="o">=</span><span class="n">xywh</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img</span></div>

<div class="viewcode-block" id="Slide.slide2vips"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.slide2vips">[docs]</a>    <span class="k">def</span> <span class="nf">slide2vips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xywh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert slide to pyvips.Image</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        level : int</span>
<span class="sd">            Pyramid level</span>

<span class="sd">        series : int, optional</span>
<span class="sd">            Series number. Defaults to 0</span>

<span class="sd">        xywh : tuple of int, optional</span>
<span class="sd">            The region to be sliced from the slide. If None,</span>
<span class="sd">            then the entire slide will be converted. Otherwise</span>
<span class="sd">            xywh is the (top left x, top left y, width, height) of</span>
<span class="sd">            the region to be sliced.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vips_slide : pyvips.Image</span>
<span class="sd">            An of the slide or the region defined by xywh</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vips_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">slide2vips</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span> <span class="n">xywh</span><span class="o">=</span><span class="n">xywh</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vips_img</span></div>

    <span class="k">def</span> <span class="nf">get_aligned_to_ref_slide_crop_xywh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_img_shape_rc</span><span class="p">,</span> <span class="n">ref_M</span><span class="p">,</span> <span class="n">scaled_ref_img_shape_rc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get bounding box used to crop slide to fit in reference image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref_img_shape_rc : tuple of int</span>
<span class="sd">            shape of reference image used to find registration parameters, i.e. processed image)</span>

<span class="sd">        ref_M : ndarray</span>
<span class="sd">            Transformation matrix for the reference image</span>

<span class="sd">        scaled_ref_img_shape_rc : tuple of int, optional</span>
<span class="sd">            shape of scaled image with shape `img_shape_rc`, i.e. slide corresponding</span>
<span class="sd">            to the image used to find the registration parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        crop_xywh : tuple of int</span>
<span class="sd">            Bounding box of crop area (XYWH)</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask covering reference image</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">CROP_REF</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scaled_ref_img_shape_rc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">scaled_ref_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">ref_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scaled_ref_img_shape_rc</span> <span class="o">=</span> <span class="n">ref_img_shape_rc</span>
            <span class="n">sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">reg_txy</span> <span class="o">=</span> <span class="o">-</span><span class="n">ref_M</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">slide_xywh</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">reg_txy</span><span class="o">*</span><span class="n">sxy</span><span class="p">,</span> <span class="o">*</span><span class="n">scaled_ref_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">slide_xywh</span><span class="p">,</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">get_overlap_crop_xywh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">warped_img_shape_rc</span><span class="p">,</span> <span class="n">scaled_warped_img_shape_rc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get bounding box used to crop slide to where all slides overlap</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        warped_img_shape_rc : tuple of int</span>
<span class="sd">            shape of registered image</span>

<span class="sd">        warped_scaled_img_shape_rc : tuple of int, optional</span>
<span class="sd">            shape of scaled registered image (i.e. registered slied)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        crop_xywh : tuple of int</span>
<span class="sd">            Bounding box of crop area (XYWH)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="p">,</span> <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">CROP_OVERLAP</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scaled_warped_img_shape_rc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">scaled_warped_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">warped_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">to_slide_transformer</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">sxy</span><span class="p">)</span>
        <span class="n">overlap_bbox</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">bbox2xy</span><span class="p">(</span><span class="n">mask_bbox_xywh</span><span class="p">)</span>
        <span class="n">scaled_overlap_bbox</span> <span class="o">=</span> <span class="n">to_slide_transformer</span><span class="p">(</span><span class="n">overlap_bbox</span><span class="p">)</span>
        <span class="n">scaled_overlap_xywh</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">scaled_overlap_bbox</span><span class="p">)</span>

        <span class="n">scaled_overlap_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">scaled_overlap_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="n">scaled_overlap_xywh</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">scaled_overlap_xywh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">scaled_overlap_xywh</span><span class="p">,</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">get_crop_xywh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop</span><span class="p">,</span> <span class="n">out_shape_rc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get bounding box used to crop aligned slide</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        out_shape_rc : tuple of int, optional</span>
<span class="sd">            If crop is &quot;reference&quot;, this should be the shape of scaled reference image, such</span>
<span class="sd">            as the unwarped slide that corresponds to the unwarped processed reference image.</span>

<span class="sd">            If crop is &quot;overlap&quot;, this should be the shape of the registered slides.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        crop_xywh : tuple of int</span>
<span class="sd">            Bounding box of crop area (XYWH)</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask, before crop</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">crop</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
            <span class="n">transformation_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">)</span>
            <span class="n">crop_xywh</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aligned_to_ref_slide_crop_xywh</span><span class="p">(</span><span class="n">ref_img_shape_rc</span><span class="o">=</span><span class="n">transformation_shape_rc</span><span class="p">,</span>
                                                                      <span class="n">ref_M</span><span class="o">=</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                                      <span class="n">scaled_ref_img_shape_rc</span><span class="o">=</span><span class="n">out_shape_rc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">crop</span> <span class="o">==</span> <span class="n">CROP_OVERLAP</span><span class="p">:</span>
            <span class="n">transformation_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">)</span>
            <span class="n">crop_xywh</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_overlap_crop_xywh</span><span class="p">(</span><span class="n">warped_img_shape_rc</span><span class="o">=</span><span class="n">transformation_shape_rc</span><span class="p">,</span>
                                                         <span class="n">scaled_warped_img_shape_rc</span><span class="o">=</span><span class="n">out_shape_rc</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">crop_xywh</span><span class="p">,</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">get_crop_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get string or logic defining how to crop the image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">crop</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">crop_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">crop_method</span> <span class="o">=</span> <span class="n">crop</span>

        <span class="n">do_crop</span> <span class="o">=</span> <span class="n">crop_method</span> <span class="ow">in</span> <span class="p">[</span><span class="n">CROP_REF</span><span class="p">,</span> <span class="n">CROP_OVERLAP</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">do_crop</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">crop_method</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_bg_color_px_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get position of pixel that has color used for background</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_type</span> <span class="o">==</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span><span class="p">:</span>
            <span class="c1">#RGB. Get brightest pixel</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="k">with</span> <span class="n">colour</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">suppress_warnings</span><span class="p">(</span><span class="n">colour_usage_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">255</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                    <span class="n">cam</span> <span class="o">=</span> <span class="n">colour</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">/</span><span class="mi">255</span> <span class="o">+</span> <span class="n">eps</span><span class="p">,</span> <span class="s1">&#39;sRGB&#39;</span><span class="p">,</span> <span class="s1">&#39;CAM16UCS&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cam</span> <span class="o">=</span> <span class="n">colour</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">+</span> <span class="n">eps</span><span class="p">,</span> <span class="s1">&#39;sRGB&#39;</span><span class="p">,</span> <span class="s1">&#39;CAM16UCS&#39;</span><span class="p">)</span>

            <span class="n">lum</span> <span class="o">=</span> <span class="n">cam</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">bg_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">lum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">lum</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># IF. Get darkest pixel</span>
            <span class="n">sum_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">bg_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">sum_img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">sum_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bg_px_pos_rc</span> <span class="o">=</span> <span class="n">bg_px</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">bg_px</span><span class="p">])</span>

<div class="viewcode-block" id="Slide.warp_img"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_img">[docs]</a>    <span class="k">def</span> <span class="nf">warp_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Warp an image using the registration parameters</span>

<span class="sd">        img : ndarray, optional</span>
<span class="sd">            The image to be warped. If None, then Slide.image</span>
<span class="sd">            will be warped.</span>

<span class="sd">        non_rigid : bool</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied.</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : ndarray</span>
<span class="sd">            Warped copy of `img`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>

        <span class="k">if</span> <span class="n">non_rigid</span><span class="p">:</span>
            <span class="n">dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;scaling transformation for image with different shape. &quot;</span>
                   <span class="s2">&quot;However, without knowing all of other image&#39;s shapes, &quot;</span>
                   <span class="s2">&quot;the scaling may not be the same for all images, and so&quot;</span>
                   <span class="s2">&quot;may not overlap.&quot;</span>
                   <span class="p">)</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">same_shape</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">img_scale_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">))</span>
            <span class="n">out_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">)</span><span class="o">*</span><span class="n">img_scale_rc</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">same_shape</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">out_shape_rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span>

        <span class="n">crop_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_method</span><span class="p">(</span><span class="n">crop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">crop_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
                <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">same_shape</span><span class="p">:</span>
                    <span class="n">scaled_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">)</span><span class="o">*</span><span class="n">img_scale_rc</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">scaled_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span>
            <span class="k">elif</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_OVERLAP</span><span class="p">:</span>
                <span class="n">scaled_shape_rc</span> <span class="o">=</span> <span class="n">out_shape_rc</span>

            <span class="n">bbox_xywh</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_xywh</span><span class="p">(</span><span class="n">crop_method</span><span class="p">,</span> <span class="n">scaled_shape_rc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bbox_xywh</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">bg_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bg_color</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">warped_img</span> <span class="o">=</span> \
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                <span class="n">bk_dxdy</span><span class="o">=</span><span class="n">dxdy</span><span class="p">,</span>
                                <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">out_shape_rc</span><span class="p">,</span>
                                <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                <span class="n">bbox_xywh</span><span class="o">=</span><span class="n">bbox_xywh</span><span class="p">,</span>
                                <span class="n">bg_color</span><span class="o">=</span><span class="n">bg_color</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">warped_img</span></div>

<div class="viewcode-block" id="Slide.warp_slide"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_slide">[docs]</a>    <span class="nd">@valtils</span><span class="o">.</span><span class="n">deprecated_args</span><span class="p">(</span><span class="n">crop_to_overlap</span><span class="o">=</span><span class="s2">&quot;crop&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">warp_slide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">src_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Warp a slide using registration parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int</span>
<span class="sd">            Pyramid level to be warped</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied. Default is True</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        src_f : str, optional</span>
<span class="sd">           Path of slide to be warped. If None (the default), Slide.src_f</span>
<span class="sd">           will be used. Otherwise, the file to which `src_f` points to should</span>
<span class="sd">           be an alternative copy of the slide, such as one that has undergone</span>
<span class="sd">           processing (e.g. stain segmentation), has a mask applied, etc...</span>

<span class="sd">        interp_method : str</span>
<span class="sd">            Interpolation method used when warping slide. Default is &quot;bicubic&quot;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">src_f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">src_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_f</span>

        <span class="k">if</span> <span class="n">non_rigid</span><span class="p">:</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Need slide level to be an integer indicating pyramid level&quot;</span>
                <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span>

        <span class="n">crop_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_method</span><span class="p">(</span><span class="n">crop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">crop_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
                <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
                <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_OVERLAP</span><span class="p">:</span>
                <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">aligned_slide_shape</span>

            <span class="n">slide_bbox_xywh</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_xywh</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="n">crop_method</span><span class="p">,</span>
                                                    <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">scaled_aligned_shape_rc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">slide_bbox_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">==</span><span class="n">scaled_aligned_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slide_bbox_xywh</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">src_f</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_f</span><span class="p">:</span>
            <span class="n">bg_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bg_color</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">warped_slide</span> <span class="o">=</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">warp_slide</span><span class="p">(</span><span class="n">src_f</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                              <span class="n">in_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                              <span class="n">aligned_img_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                              <span class="n">aligned_slide_shape_rc</span><span class="o">=</span><span class="n">aligned_slide_shape</span><span class="p">,</span>
                                              <span class="n">dxdy</span><span class="o">=</span><span class="n">bk_dxdy</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">,</span>
                                              <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">,</span>
                                              <span class="n">bbox_xywh</span><span class="o">=</span><span class="n">slide_bbox_xywh</span><span class="p">,</span>
                                              <span class="n">bg_color</span><span class="o">=</span><span class="n">bg_color</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">warped_slide</span></div>

<div class="viewcode-block" id="Slide.warp_and_save_slide"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_and_save_slide">[docs]</a>    <span class="nd">@valtils</span><span class="o">.</span><span class="n">deprecated_args</span><span class="p">(</span><span class="n">crop_to_overlap</span><span class="o">=</span><span class="s2">&quot;crop&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">warp_and_save_slide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dst_f</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">src_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">channel_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">,</span>
                            <span class="n">tile_wh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Warp and save a slide</span>

<span class="sd">        Slides will be saved in the ome.tiff format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dst_f : str</span>
<span class="sd">            Path to were the warped slide will be saved.</span>

<span class="sd">        level : int</span>
<span class="sd">            Pyramid level to be warped</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied. Default is True</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        channel_names : list, optional</span>
<span class="sd">            List of channel names. If None, then Slide.reader</span>
<span class="sd">            will attempt to find the channel names associated with `src_f`.</span>

<span class="sd">        src_f : str, optional</span>
<span class="sd">           Path of slide to be warped. If None (the deffault), Slide.src_f</span>
<span class="sd">           will be used. Otherwise, the file to which `src_f` points to should</span>
<span class="sd">           be an alternative copy of the slide, such as one that has undergone</span>
<span class="sd">           processing (e.g. stain segmentation), has a mask applied, etc...</span>

<span class="sd">        interp_method : str</span>
<span class="sd">            Interpolation method used when warping slide. Default is &quot;bicubic&quot;</span>

<span class="sd">        tile_wh : int, optional</span>
<span class="sd">            Tile width and height used to save image</span>

<span class="sd">        compression : str</span>
<span class="sd">            Compression method used to save ome.tiff . Default is lzw, but can also</span>
<span class="sd">            be jpeg or jp2k. See pyips for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">warped_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp_slide</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="n">non_rigid</span><span class="p">,</span>
                                       <span class="n">crop</span><span class="o">=</span><span class="n">crop</span><span class="p">,</span>
                                       <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">)</span>

        <span class="c1"># Get ome-xml #</span>
        <span class="n">slide_meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span>
        <span class="k">if</span> <span class="n">slide_meta</span><span class="o">.</span><span class="n">pixel_physical_size_xyu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">PIXEL_UNIT</span><span class="p">:</span>
            <span class="n">px_phys_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">px_phys_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">scale_physical_size</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">channel_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">src_f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">channel_names</span> <span class="o">=</span> <span class="n">slide_meta</span><span class="o">.</span><span class="n">channel_names</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reader_cls</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">get_slide_reader</span><span class="p">(</span><span class="n">src_f</span><span class="p">)</span>
                <span class="n">reader</span> <span class="o">=</span> <span class="n">reader_cls</span><span class="p">(</span><span class="n">src_f</span><span class="p">)</span>
                <span class="n">channel_names</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">channel_names</span>

        <span class="n">bf_dtype</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">vips2bf_dtype</span><span class="p">(</span><span class="n">warped_slide</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="n">out_xyczt</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">get_shape_xyzct</span><span class="p">((</span><span class="n">warped_slide</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">warped_slide</span><span class="o">.</span><span class="n">height</span><span class="p">),</span> <span class="n">warped_slide</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span>
        <span class="n">ome_xml_obj</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">update_xml_for_new_img</span><span class="p">(</span><span class="n">slide_meta</span><span class="o">.</span><span class="n">original_xml</span><span class="p">,</span>
                                                      <span class="n">new_xyzct</span><span class="o">=</span><span class="n">out_xyczt</span><span class="p">,</span>
                                                      <span class="n">bf_dtype</span><span class="o">=</span><span class="n">bf_dtype</span><span class="p">,</span>
                                                      <span class="n">is_rgb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_rgb</span><span class="p">,</span>
                                                      <span class="n">pixel_physical_size_xyu</span><span class="o">=</span><span class="n">px_phys_size</span><span class="p">,</span>
                                                      <span class="n">channel_names</span><span class="o">=</span><span class="n">channel_names</span><span class="p">,</span>
                                                      <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="n">perceputally_uniform_channel_colors</span>
                                                      <span class="p">)</span>

        <span class="n">ome_xml</span> <span class="o">=</span> <span class="n">ome_xml_obj</span><span class="o">.</span><span class="n">to_xml</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tile_wh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tile_wh</span> <span class="o">=</span> <span class="n">slide_meta</span><span class="o">.</span><span class="n">optimal_tile_wh</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">down_sampling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">slide_meta</span><span class="o">.</span><span class="n">slide_dimensions</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">/</span><span class="n">slide_meta</span><span class="o">.</span><span class="n">slide_dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">tile_wh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tile_wh</span><span class="o">*</span><span class="n">down_sampling</span><span class="p">))</span>
                <span class="n">tile_wh</span> <span class="o">=</span> <span class="n">tile_wh</span> <span class="o">-</span> <span class="p">(</span><span class="n">tile_wh</span> <span class="o">%</span> <span class="mi">16</span><span class="p">)</span>  <span class="c1"># Tile shape must be multiple of 16</span>
                <span class="k">if</span> <span class="n">tile_wh</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
                    <span class="n">tile_wh</span> <span class="o">=</span> <span class="mi">16</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tile_wh</span><span class="p">):</span>
                    <span class="n">tile_wh</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">slide_io</span><span class="o">.</span><span class="n">save_ome_tiff</span><span class="p">(</span><span class="n">warped_slide</span><span class="p">,</span> <span class="n">dst_f</span><span class="o">=</span><span class="n">dst_f</span><span class="p">,</span> <span class="n">ome_xml</span><span class="o">=</span><span class="n">ome_xml</span><span class="p">,</span>
                               <span class="n">tile_wh</span><span class="o">=</span><span class="n">tile_wh</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span></div>

<div class="viewcode-block" id="Slide.warp_xy"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_xy">[docs]</a>    <span class="k">def</span> <span class="nf">warp_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slide_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pt_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Warp points using registration parameters</span>

<span class="sd">        Warps `xy` to their location in the registered slide/image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy : ndarray</span>
<span class="sd">            (N, 2) array of points to be warped. Must be x,y coordinates</span>

<span class="sd">        slide_level: int, tuple, optional</span>
<span class="sd">            Pyramid level of the slide. Used to scale transformation matrices.</span>
<span class="sd">            Can also be the shape of the unwarped image (row, col) into which</span>
<span class="sd">            the points should be warped. Default is 0.</span>

<span class="sd">        pt_level: int, tuple, optional</span>
<span class="sd">            Pyramid level from which the points origingated. For example, if</span>
<span class="sd">            `xy` are from the centroids of cell segmentation performed on the</span>
<span class="sd">            full resolution image, this should be 0. Alternatively, the value can</span>
<span class="sd">            be a tuple of the image&#39;s shape (row, col) from which the points came.</span>
<span class="sd">            For example, if `xy` are  bounding box coordinates from an analysis on</span>
<span class="sd">            a lower resolution image, then pt_level is that lower resolution</span>
<span class="sd">            image&#39;s shape (row, col). Default is 0.</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied. Default is True.</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            Apply crop to warped points by shifting points to the mask&#39;s origin.</span>
<span class="sd">            Note that this can result in negative coordinates, but might be useful</span>
<span class="sd">            if wanting to draw the coordinates on the registered slide, such as</span>
<span class="sd">            annotation coordinates.</span>

<span class="sd">            If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pt_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">pt_dim_rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">pt_level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pt_dim_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">slide_level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">slide_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="n">slide_level</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span>

        <span class="k">if</span> <span class="n">non_rigid</span><span class="p">:</span>
            <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">warped_xy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span>
                                       <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">src_shape_rc</span><span class="o">=</span><span class="n">pt_dim_rc</span><span class="p">,</span>
                                       <span class="n">dst_shape_rc</span><span class="o">=</span><span class="n">aligned_slide_shape</span><span class="p">,</span>
                                       <span class="n">fwd_dxdy</span><span class="o">=</span><span class="n">fwd_dxdy</span><span class="p">)</span>

        <span class="n">crop_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_method</span><span class="p">(</span><span class="n">crop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">crop_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
                <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slide_level</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">slide_level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slide_level</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">slide_level</span>
            <span class="k">elif</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_OVERLAP</span><span class="p">:</span>
                <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">aligned_slide_shape</span>

            <span class="n">crop_bbox_xywh</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_xywh</span><span class="p">(</span><span class="n">crop_method</span><span class="p">,</span> <span class="n">scaled_aligned_shape_rc</span><span class="p">)</span>
            <span class="n">warped_xy</span> <span class="o">-=</span> <span class="n">crop_bbox_xywh</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">warped_xy</span></div>

<div class="viewcode-block" id="Slide.warp_xy_from_to"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_xy_from_to">[docs]</a>    <span class="k">def</span> <span class="nf">warp_xy_from_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">to_slide_obj</span><span class="p">,</span> <span class="n">src_pt_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">dst_slide_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Warp points from this slide to another unwarped slide</span>

<span class="sd">        Takes a set of points found in this unwarped slide, and warps them to</span>
<span class="sd">        their position in the unwarped &quot;to&quot; slide.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy : ndarray</span>
<span class="sd">            (N, 2) array of points to be warped. Must be x,y coordinates</span>

<span class="sd">        to_slide_obj : Slide</span>
<span class="sd">            Slide to which the points will be warped. I.e. `xy`</span>
<span class="sd">            will be warped from this Slide to their position in</span>
<span class="sd">            the unwarped slide associated with `to_slide_obj`.</span>

<span class="sd">        src_pt_level: int, tuple, optional</span>
<span class="sd">            Pyramid level of the slide/image in which `xy` originated.</span>
<span class="sd">            For example, if `xy` are from the centroids of cell segmentation</span>
<span class="sd">            performed on the unwarped full resolution image, this should be 0.</span>
<span class="sd">            Alternatively, the value can be a tuple of the image&#39;s shape (row, col)</span>
<span class="sd">            from which the points came. For example, if `xy` are  bounding</span>
<span class="sd">            box coordinates from an analysis on a lower resolution image,</span>
<span class="sd">            then pt_level is that lower resolution image&#39;s shape (row, col).</span>

<span class="sd">        dst_slide_level: int, tuple, optional</span>
<span class="sd">            Pyramid level of the slide/image in to `xy` will be warped.</span>
<span class="sd">            Similar to `src_pt_level`, if `dst_slide_level` is an int then</span>
<span class="sd">            the points will be warped to that pyramid level. If `dst_slide_level`</span>
<span class="sd">            is the &quot;to&quot; image&#39;s shape (row, col), then the points will be warped</span>
<span class="sd">            to their location in an image with that same shape.</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">src_pt_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">src_pt_dim_rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">src_pt_level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">src_pt_dim_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">src_pt_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dst_slide_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">dst_shape_rc</span> <span class="o">=</span> <span class="n">to_slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">dst_slide_level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dst_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dst_slide_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">non_rigid</span><span class="p">:</span>
            <span class="n">src_fwd_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span>
            <span class="n">dst_bk_dxdy</span> <span class="o">=</span> <span class="n">to_slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">src_fwd_dxdy</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dst_bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">xy_in_unwarped_to_img</span> <span class="o">=</span> \
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy_from_to</span><span class="p">(</span><span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
                                       <span class="n">from_M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                       <span class="n">registered_img_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">from_transformation_src_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">from_src_shape_rc</span><span class="o">=</span><span class="n">src_pt_dim_rc</span><span class="p">,</span>
                                       <span class="n">from_fwd_dxdy</span><span class="o">=</span><span class="n">src_fwd_dxdy</span><span class="p">,</span>
                                       <span class="n">to_M</span><span class="o">=</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                       <span class="n">to_transformation_src_shape_rc</span><span class="o">=</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">to_src_shape_rc</span><span class="o">=</span><span class="n">dst_shape_rc</span><span class="p">,</span>
                                       <span class="n">to_bk_dxdy</span><span class="o">=</span><span class="n">dst_bk_dxdy</span>
                                       <span class="p">)</span>

        <span class="k">return</span> <span class="n">xy_in_unwarped_to_img</span></div></div>


<div class="viewcode-block" id="Valis"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis">[docs]</a><span class="k">class</span> <span class="nc">Valis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reads, registers, and saves a series of slides/images</span>

<span class="sd">    Implements the registration pipeline described in</span>
<span class="sd">    &quot;VALIS: Virtual Alignment of pathoLogy Image Series&quot; by Gatenbee et al.</span>
<span class="sd">    This pipeline will read images and whole slide images (WSI) using pyvips,</span>
<span class="sd">    bioformats, or openslide, and so should work with a wide variety of formats.</span>
<span class="sd">    VALIS can perform both rigid and non-rigid registration. The registered slides</span>
<span class="sd">    can be saved as ome.tiff slides that can be used in downstream analyses. The</span>
<span class="sd">    ome.tiff format is opensource and widely supported, being readable in several</span>
<span class="sd">    different programming languages (Python, Java, Matlab, etc...) and software,</span>
<span class="sd">    such as QuPath or HALO.</span>

<span class="sd">    The pipeline is fully automated and goes as follows:</span>

<span class="sd">    1. Images/slides are converted to numpy arrays. As WSI are often</span>
<span class="sd">    too large to fit into memory, these images are usually lower resolution</span>
<span class="sd">    images from different pyramid levels.</span>

<span class="sd">    2. Images are processed to single channel images. They are then</span>
<span class="sd">    normalized to make them look as similar as possible.</span>

<span class="sd">    3. Image features are detected and then matched between all pairs of image.</span>

<span class="sd">    4. If the order of images is unknown, they will be optimally ordered</span>
<span class="sd">    based on their feature similarity</span>

<span class="sd">    5. Rigid registration is performed serially, with each image being</span>
<span class="sd">    rigidly aligned to the previous image in the stack.</span>

<span class="sd">    6. Non-rigid registration is then performed either by 1) aliging each image</span>
<span class="sd">    towards the center of the stack, composing the deformation fields</span>
<span class="sd">    along the way, or 2) using groupwise registration that non-rigidly aligns</span>
<span class="sd">    the images to a common frame of reference.</span>

<span class="sd">    7. Error is measured by calculating the distance between registered</span>
<span class="sd">    matched features.</span>

<span class="sd">    The transformations found by VALIS can then be used to warp the full</span>
<span class="sd">    resolution slides. It is also possible to merge non-RGB registered slides</span>
<span class="sd">    to create a highly multiplexed image. These aligned and/or merged slides</span>
<span class="sd">    can then be saved as ome.tiff images using pyvips.</span>

<span class="sd">    In addition to warping images and slides, VALIS can also warp point data,</span>
<span class="sd">    such as cell centoids or ROI coordinates.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Descriptive name of registrar, such as the sample&#39;s name.</span>

<span class="sd">    src_dir: str</span>
<span class="sd">        Path to directory containing the slides that will be registered.</span>

<span class="sd">    dst_dir : str</span>
<span class="sd">        Path to where the results should be saved.</span>

<span class="sd">    original_img_list : list of ndarray</span>
<span class="sd">        List of images converted from the slides in `src_dir`</span>

<span class="sd">    slide_dims_dict_wh :</span>
<span class="sd">        Dictionary of slide dimensions. Only needed if dimensions not</span>
<span class="sd">        available in the slide/image&#39;s metadata.</span>

<span class="sd">    resolution_xyu: tuple</span>
<span class="sd">        Physical size per pixel and the unit.</span>

<span class="sd">    image_type : str</span>
<span class="sd">        Type of image, i.e. &quot;brightfield&quot; or &quot;fluorescence&quot;</span>

<span class="sd">    series : int</span>
<span class="sd">        Slide series to that was read.</span>

<span class="sd">    size : int</span>
<span class="sd">        Number of images to align</span>

<span class="sd">    aligned_img_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of aligned images</span>

<span class="sd">    aligned_slide_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of the aligned slides</span>

<span class="sd">    slide_dict : dict of Slide</span>
<span class="sd">        Dictionary of Slide objects, each of which contains information</span>
<span class="sd">        about a slide, and methods to warp it.</span>

<span class="sd">    brightfield_procsseing_fxn_str: str</span>
<span class="sd">        Name of function used to process brightfield images.</span>

<span class="sd">    if_procsseing_fxn_str : str</span>
<span class="sd">        Name of function used to process fluorescence images.</span>

<span class="sd">    max_image_dim_px : int</span>
<span class="sd">        Maximum width or height of images that will be saved.</span>
<span class="sd">        This limit is mostly to keep memory in check.</span>

<span class="sd">    max_processed_image_dim_px : int</span>
<span class="sd">        Maximum width or height of processed images. An important</span>
<span class="sd">        parameter, as it determines the size of of the image in which</span>
<span class="sd">        features will be detected and displacement fields computed.</span>

<span class="sd">    reference_img_f : str</span>
<span class="sd">        Filename of image that will be treated as the center of the stack.</span>
<span class="sd">        If None, the index of the middle image will be the reference.</span>

<span class="sd">    reference_img_idx : int</span>
<span class="sd">        Index of slide that corresponds to `reference_img_f`, after</span>
<span class="sd">        the `img_obj_list` has been sorted during rigid registration.</span>

<span class="sd">    crop: str, optional</span>
<span class="sd">        How to crop the registered images.</span>

<span class="sd">    rigid_registrar : SerialRigidRegistrar</span>
<span class="sd">        SerialRigidRegistrar object that performs the rigid registration.</span>

<span class="sd">    rigid_reg_kwargs : dict</span>
<span class="sd">        Dictionary of keyward arguments passed to</span>
<span class="sd">        `serial_rigid.register_images`.</span>

<span class="sd">    feature_descriptor_str : str</span>
<span class="sd">        Name of feature descriptor.</span>

<span class="sd">    feature_detector_str : str</span>
<span class="sd">        Name of feature detector.</span>

<span class="sd">    transform_str : str</span>
<span class="sd">        Name of rigid transform</span>

<span class="sd">    similarity_metric : str</span>
<span class="sd">        Name of similarity metric used to order slides.</span>

<span class="sd">    match_filter_method : str</span>
<span class="sd">        Name of method used to filter out poor feature matches.</span>

<span class="sd">    non_rigid_registrar : SerialNonRigidRegistrar</span>
<span class="sd">        SerialNonRigidRegistrar object that performs serial</span>
<span class="sd">        non-rigid registration.</span>

<span class="sd">    non_rigid_reg_kwargs : dict</span>
<span class="sd">        Dictionary of keyward arguments passed to</span>
<span class="sd">        `serial_non_rigid.register_images`.</span>

<span class="sd">    non_rigid_registrar_cls : NonRigidRegistrar</span>
<span class="sd">        Uninstantiated NonRigidRegistrar class that will be used</span>
<span class="sd">        by `non_rigid_registrar` to calculate the deformation fields</span>
<span class="sd">        between images.</span>

<span class="sd">    non_rigid_reg_class_str : str</span>
<span class="sd">        Name of the of class `non_rigid_registrar_cls` belongs to.</span>

<span class="sd">    thumbnail_size : int</span>
<span class="sd">        Maximum width or height of thumbnails that show results</span>

<span class="sd">    original_overlap_img : ndarray</span>
<span class="sd">        Image showing how original images overlap before registration.</span>
<span class="sd">        Created by merging coloring the inverted greyscale copies of each</span>
<span class="sd">        image, and then merging those images.</span>

<span class="sd">    rigid_overlap_img : ndarray</span>
<span class="sd">        Image showing how images overlap after rigid registration.</span>

<span class="sd">    non_rigid_overlap_img : ndarray</span>
<span class="sd">        Image showing how images overlap after rigid + non-rigid registration.</span>

<span class="sd">    has_rounds : bool</span>
<span class="sd">        Whether or not the contents of `src_dir` contain subdirectories that</span>
<span class="sd">        have single images spread across multiple files. An example would be</span>
<span class="sd">        .ndpis images.</span>

<span class="sd">    norm_method : str</span>
<span class="sd">        Name of method used to normalize the processed images</span>

<span class="sd">    summary_df : pd.Dataframe</span>
<span class="sd">        Pandas dataframe containing information about the results, such</span>
<span class="sd">        as the error, shape of aligned slides, time to completion, etc...</span>

<span class="sd">    start_time : float</span>
<span class="sd">        The time at which registation was initiated.</span>

<span class="sd">    end_rigid_time : float</span>
<span class="sd">        The time at which rigid registation was completed.</span>

<span class="sd">    end_non_rigid_time : float</span>
<span class="sd">        The time at which non-rigid registation was completed.</span>

<span class="sd">    qt_emitter : PySide2.QtCore.Signal</span>
<span class="sd">        Used to emit signals that update the GUI&#39;s progress bars</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Basic example using default parameters</span>

<span class="sd">    &gt;&gt;&gt; from valis import registration, data</span>
<span class="sd">    &gt;&gt;&gt; slide_src_dir = data.dcis_src_dir</span>
<span class="sd">    &gt;&gt;&gt; results_dst_dir = &quot;./slide_registration_example&quot;</span>
<span class="sd">    &gt;&gt;&gt; registered_slide_dst_dir = &quot;./slide_registration_example/registered_slides&quot;</span>

<span class="sd">    Perform registration</span>

<span class="sd">    &gt;&gt;&gt; rigid_registrar, non_rigid_registrar, error_df = registrar.register()</span>

<span class="sd">    View results in &quot;./slide_registration_example&quot;.</span>
<span class="sd">    If they look good, warp and save the slides as ome.tiff</span>

<span class="sd">    &gt;&gt;&gt; registrar.warp_and_save_slides(registered_slide_dst_dir)</span>

<span class="sd">    This example shows how to register CyCIF images and then merge</span>
<span class="sd">    to create a high dimensional ome.tiff slide</span>

<span class="sd">    &gt;&gt;&gt; registrar = registration.Valis(slide_src_dir, results_dst_dir)</span>
<span class="sd">    &gt;&gt;&gt; rigid_registrar, non_rigid_registrar, error_df = registrar.register()</span>

<span class="sd">    Create function to get marker names from each slides&#39; filename</span>

<span class="sd">    &gt;&gt;&gt; def cnames_from_filename(src_f):</span>
<span class="sd">    ...     f = valtils.get_name(src_f)</span>
<span class="sd">    ...     return [&quot;DAPI&quot;] + f.split(&quot; &quot;)[1:4]</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; channel_name_dict = {f:cnames_from_filename(f) for f in  registrar.original_img_list}</span>
<span class="sd">    &gt;&gt;&gt; merged_img, channel_names, ome_xml = registrar.warp_and_merge_slides(merged_slide_dst_f, channel_name_dict=channel_name_dict)</span>

<span class="sd">    View ome.tiff, located at merged_slide_dst_f</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Valis.__init__"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_dir</span><span class="p">,</span> <span class="n">dst_dir</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">img_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">feature_detector_cls</span><span class="o">=</span><span class="n">DEFAULT_FD</span><span class="p">,</span>
                 <span class="n">transformer_cls</span><span class="o">=</span><span class="n">DEFAULT_TRANSFORM_CLASS</span><span class="p">,</span>
                 <span class="n">affine_optimizer_cls</span><span class="o">=</span><span class="n">DEFAULT_AFFINE_OPTIMIZER_CLASS</span><span class="p">,</span>
                 <span class="n">similarity_metric</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_METRIC</span><span class="p">,</span>
                 <span class="n">match_filter_method</span><span class="o">=</span><span class="n">DEFAULT_MATCH_FILTER</span><span class="p">,</span>
                 <span class="n">imgs_ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">non_rigid_registrar_cls</span><span class="o">=</span><span class="n">DEFAULT_NON_RIGID_CLASS</span><span class="p">,</span>
                 <span class="n">non_rigid_reg_params</span><span class="o">=</span><span class="n">DEFAULT_NON_RIGID_KWARGS</span><span class="p">,</span>
                 <span class="n">img_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reference_img_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">crop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">resolution_xyu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slide_dims_dict_wh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_image_dim_px</span><span class="o">=</span><span class="n">DEFAULT_MAX_IMG_DIM</span><span class="p">,</span>
                 <span class="n">max_processed_image_dim_px</span><span class="o">=</span><span class="n">DEFAULT_MAX_PROCESSED_IMG_SIZE</span><span class="p">,</span>
                 <span class="n">thumbnail_size</span><span class="o">=</span><span class="n">DEFAULT_THUMBNAIL_SIZE</span><span class="p">,</span>
                 <span class="n">norm_method</span><span class="o">=</span><span class="n">DEFAULT_NORM_METHOD</span><span class="p">,</span> <span class="n">qt_emitter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        src_dir: str</span>
<span class="sd">            Path to directory containing the slides that will be registered.</span>

<span class="sd">        dst_dir : str</span>
<span class="sd">            Path to where the results should be saved.</span>

<span class="sd">        name : str, optional</span>
<span class="sd">            Descriptive name of registrar, such as the sample&#39;s name</span>

<span class="sd">        series : int, optional</span>
<span class="sd">            Slide series to that was read. If None, series will be set to 0.</span>

<span class="sd">        img_type : str, optional</span>
<span class="sd">            The type of image, either &quot;brightfield&quot;, &quot;fluorescence&quot;,</span>
<span class="sd">            or &quot;multi&quot;. If None, VALIS will guess `img_type`</span>
<span class="sd">            of each image, based on the number of channels and datatype.</span>
<span class="sd">            Will assume that RGB = &quot;brightfield&quot;,</span>
<span class="sd">            otherwise `img_type` will be set to &quot;fluorescence&quot;.</span>

<span class="sd">        feature_detector_cls : FeatureDD, optional</span>
<span class="sd">            Uninstantiated FeatureDD object that detects and computes</span>
<span class="sd">            image features. Default is VggFD. The</span>
<span class="sd">            available feature_detectors are found in the `feature_detectors`</span>
<span class="sd">            module. If a desired feature detector is not available,</span>
<span class="sd">            one can be created by subclassing `feature_detectors.FeatureDD`.</span>

<span class="sd">        transformer_cls : scikit-image Transform class, optional</span>
<span class="sd">            Uninstantiated scikit-image transformer used to find</span>
<span class="sd">            transformation matrix that will warp each image to the target</span>
<span class="sd">            image. Default is SimilarityTransform</span>

<span class="sd">        affine_optimizer_cls : AffineOptimzer class, optional</span>
<span class="sd">            Uninstantiated AffineOptimzer that will minimize a</span>
<span class="sd">            cost function to find the optimal affine transformations.</span>
<span class="sd">            If a desired affine optimization is not available,</span>
<span class="sd">            one can be created by subclassing `affine_optimizer.AffineOptimizer`.</span>

<span class="sd">        similarity_metric : str, optional</span>
<span class="sd">            Metric used to calculate similarity between images, which is in</span>
<span class="sd">            turn used to build the distance matrix used to sort the images.</span>
<span class="sd">            Can be &quot;n_matches&quot;, or a string to used as</span>
<span class="sd">            distance in spatial.distance.cdist. &quot;n_matches&quot;</span>
<span class="sd">            is the number of matching features between image pairs.</span>

<span class="sd">        match_filter_method: str, optional</span>
<span class="sd">            &quot;GMS&quot; will use filter_matches_gms() to remove poor matches.</span>
<span class="sd">            This uses the Grid-based Motion Statistics (GMS) or RANSAC.</span>

<span class="sd">        imgs_ordered : bool, optional</span>
<span class="sd">            Boolean defining whether or not the order of images in img_dir</span>
<span class="sd">            are already in the correct order. If True, then each filename should</span>
<span class="sd">            begin with the number that indicates its position in the z-stack. If</span>
<span class="sd">            False, then the images will be sorted by ordering a feature distance</span>
<span class="sd">            matix. Default is False.</span>

<span class="sd">        reference_img_f : str, optional</span>
<span class="sd">            Filename of image that will be treated as the center of the stack.</span>
<span class="sd">            If None, the index of the middle image will be the reference.</span>

<span class="sd">        non_rigid_registrar_cls : NonRigidRegistrar, optional</span>
<span class="sd">            Uninstantiated NonRigidRegistrar class that will be used to</span>
<span class="sd">            calculate the deformation fields between images. See</span>
<span class="sd">            the `non_rigid_registrars` module for a desciption of available</span>
<span class="sd">            methods. If a desired non-rigid registration method is not available,</span>
<span class="sd">            one can be implemented by subclassing.NonRigidRegistrar.</span>
<span class="sd">            If None, then only rigid registration will be performed</span>

<span class="sd">        non_rigid_reg_params: dictionary, optional</span>
<span class="sd">            Dictionary containing key, value pairs to be used to initialize</span>
<span class="sd">            `non_rigid_registrar_cls`.</span>
<span class="sd">            In the case where simple ITK is used by the, params should be</span>
<span class="sd">            a SimpleITK.ParameterMap. Note that numeric values nedd to be</span>
<span class="sd">            converted to strings. See the NonRigidRegistrar classes in</span>
<span class="sd">            `non_rigid_registrars` for the available non-rigid registration</span>
<span class="sd">            methods and arguments.</span>

<span class="sd">        crop: str, optional</span>
<span class="sd">            How to crop the registered images. &quot;overlap&quot; will crop to include</span>
<span class="sd">            only areas where all images overlapped. &quot;reference&quot; crops to the</span>
<span class="sd">            area that overlaps with a reference image, defined by</span>
<span class="sd">            `reference_img_f`. This option can be used even if `reference_img_f`</span>
<span class="sd">            is `None` because the reference image will be set as the one at the center</span>
<span class="sd">            of the stack.</span>

<span class="sd">            If both `crop` and `reference_img_f` are `None`, `crop`</span>
<span class="sd">            will be set to &quot;overlap&quot;. If `crop` is None, but `reference_img_f`</span>
<span class="sd">            is defined, then `crop` will be set to &quot;reference&quot;.</span>

<span class="sd">        resolution_xyu: tuple, optional</span>
<span class="sd">            Physical size per pixel and the unit. If None (the default), these</span>
<span class="sd">            values will be determined for each slide using the slides&#39; metadata.</span>
<span class="sd">            If provided, this physical pixel sizes will be used for all of the slides.</span>
<span class="sd">            This option is available in case one cannot easily access to the original</span>
<span class="sd">            slides, but does have the information on pixel&#39;s physical units.</span>

<span class="sd">        slide_dims_dict_wh : dict, optional</span>
<span class="sd">            Key= slide/image file name,</span>
<span class="sd">            value= dimensions = [(width, height), (width, height), ...] for each level.</span>
<span class="sd">            If None (the default), the slide dimensions will be pulled from the</span>
<span class="sd">            slides&#39; metadata. If provided, those values will be overwritten. This</span>
<span class="sd">            option is available in case one cannot easily access to the original</span>
<span class="sd">            slides, but does have the information on the slide dimensions.</span>

<span class="sd">        max_image_dim_px : int, optional</span>
<span class="sd">            Maximum width or height of images that will be saved.</span>
<span class="sd">            This limit is mostly to keep memory in check.</span>

<span class="sd">        max_processed_image_dim_px : int, optional</span>
<span class="sd">            Maximum width or height of processed images. An important</span>
<span class="sd">            parameter, as it determines the size of of the image in which</span>
<span class="sd">            features will be detected and displacement fields computed.</span>

<span class="sd">        mask_dict : dictionary</span>
<span class="sd">            Dictionary where key = overlap type (all, overlap, or reference), and</span>
<span class="sd">            value = (mask, mask_bbox_xywh)</span>

<span class="sd">        thumbnail_size : int, optional</span>
<span class="sd">            Maximum width or height of thumbnails that show results</span>

<span class="sd">        norm_method : str</span>
<span class="sd">            Name of method used to normalize the processed images. Options</span>
<span class="sd">            are &quot;histo_match&quot; for histogram matching, &quot;img_stats&quot; for normalizing by</span>
<span class="sd">            image statistics. See preprocessing.match_histograms</span>
<span class="sd">            and preprocessing.norm_khan for details.</span>

<span class="sd">        qt_emitter : PySide2.QtCore.Signal, optional</span>
<span class="sd">            Used to emit signals that update the GUI&#39;s progress bars</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">src_dir</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="c1"># Set paths #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_dir</span> <span class="o">=</span> <span class="n">src_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">img_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span> <span class="o">=</span> <span class="n">img_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_imgs_in_dir</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_dst_paths</span><span class="p">()</span>

        <span class="c1"># Some information may already be provided #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slide_dims_dict_wh</span> <span class="o">=</span> <span class="n">slide_dims_dict_wh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution_xyu</span> <span class="o">=</span> <span class="n">resolution_xyu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_type</span> <span class="o">=</span> <span class="n">img_type</span>

        <span class="c1"># Results fields #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="n">series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aligned_img_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Fields related to image pre-processing #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">brightfield_procsseing_fxn_str</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">if_procsseing_fxn_str</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">max_image_dim_px</span> <span class="o">&lt;</span> <span class="n">max_processed_image_dim_px</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;max_image_dim_px is </span><span class="si">{</span><span class="n">max_image_dim_px</span><span class="si">}</span><span class="s2"> but needs to be less or equal to </span><span class="si">{</span><span class="n">max_processed_image_dim_px</span><span class="si">}</span><span class="s2">. Setting max_image_dim_px to </span><span class="si">{</span><span class="n">max_processed_image_dim_px</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">max_image_dim_px</span> <span class="o">=</span> <span class="n">max_processed_image_dim_px</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span> <span class="o">=</span> <span class="n">max_image_dim_px</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span> <span class="o">=</span> <span class="n">max_processed_image_dim_px</span>

        <span class="c1"># Setup rigid registration #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_rigid_reg_kwargs</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                   <span class="n">feature_detector</span><span class="o">=</span><span class="n">feature_detector_cls</span><span class="p">,</span>
                                   <span class="n">similarity_metric</span><span class="o">=</span><span class="n">similarity_metric</span><span class="p">,</span>
                                   <span class="n">match_filter_method</span><span class="o">=</span><span class="n">match_filter_method</span><span class="p">,</span>
                                   <span class="n">transformer</span><span class="o">=</span><span class="n">transformer_cls</span><span class="p">,</span>
                                   <span class="n">affine_optimizer</span><span class="o">=</span><span class="n">affine_optimizer_cls</span><span class="p">,</span>
                                   <span class="n">imgs_ordered</span><span class="o">=</span><span class="n">imgs_ordered</span><span class="p">,</span>
                                   <span class="n">reference_img_f</span><span class="o">=</span><span class="n">reference_img_f</span><span class="p">,</span>
                                   <span class="n">qt_emitter</span><span class="o">=</span><span class="n">qt_emitter</span><span class="p">)</span>

        <span class="c1"># Setup non-rigid registration #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span> <span class="o">=</span> <span class="n">non_rigid_registrar_cls</span>

        <span class="k">if</span> <span class="n">crop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reference_img_f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="n">CROP_OVERLAP</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="n">CROP_REF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="n">crop</span>

        <span class="k">if</span> <span class="n">non_rigid_registrar_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_non_rigid_reg_kwargs</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                           <span class="n">non_rigid_reg_class</span><span class="o">=</span><span class="n">non_rigid_registrar_cls</span><span class="p">,</span>
                                           <span class="n">non_rigid_reg_params</span><span class="o">=</span><span class="n">non_rigid_reg_params</span><span class="p">,</span>
                                           <span class="n">reference_img_f</span><span class="o">=</span><span class="n">reference_img_f</span><span class="p">,</span>
                                           <span class="n">qt_emitter</span><span class="o">=</span><span class="n">qt_emitter</span><span class="p">)</span>

        <span class="c1"># Info realted to saving images to view results #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_dict</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span> <span class="o">=</span> <span class="n">thumbnail_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_overlap_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_overlap_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_overlap_img</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">has_rounds</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">=</span> <span class="n">norm_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_rigid_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_non_rigid_time</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_set_rigid_reg_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">feature_detector</span><span class="p">,</span> <span class="n">similarity_metric</span><span class="p">,</span>
                              <span class="n">match_filter_method</span><span class="p">,</span> <span class="n">transformer</span><span class="p">,</span> <span class="n">affine_optimizer</span><span class="p">,</span>
                              <span class="n">imgs_ordered</span><span class="p">,</span> <span class="n">reference_img_f</span><span class="p">,</span> <span class="n">qt_emitter</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Set rigid registration kwargs</span>
<span class="sd">        Keyword arguments will be passed to `serial_rigid.register_images`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">matcher</span> <span class="o">=</span> <span class="n">feature_matcher</span><span class="o">.</span><span class="n">Matcher</span><span class="p">(</span><span class="n">match_filter_method</span><span class="o">=</span><span class="n">match_filter_method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">affine_optimizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">afo</span> <span class="o">=</span> <span class="n">affine_optimizer</span><span class="p">(</span><span class="n">transform</span><span class="o">=</span><span class="n">transformer</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">afo</span> <span class="o">=</span> <span class="n">affine_optimizer</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">NAME_KEY</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                                 <span class="n">FD_KEY</span><span class="p">:</span> <span class="n">feature_detector</span><span class="p">(),</span>
                                 <span class="n">SIM_METRIC_KEY</span><span class="p">:</span> <span class="n">similarity_metric</span><span class="p">,</span>
                                 <span class="n">TRANSFORMER_KEY</span><span class="p">:</span> <span class="n">transformer</span><span class="p">(),</span>
                                 <span class="n">MATCHER_KEY</span><span class="p">:</span> <span class="n">matcher</span><span class="p">,</span>
                                 <span class="n">AFFINE_OPTIMIZER_KEY</span><span class="p">:</span> <span class="n">afo</span><span class="p">,</span>
                                 <span class="n">REF_IMG_KEY</span><span class="p">:</span> <span class="n">reference_img_f</span><span class="p">,</span>
                                 <span class="n">IMAGES_ORDERD_KEY</span><span class="p">:</span> <span class="n">imgs_ordered</span><span class="p">,</span>
                                 <span class="n">QT_EMMITER_KEY</span><span class="p">:</span> <span class="n">qt_emitter</span>
                                 <span class="p">}</span>

        <span class="c1"># Save methods as strings since some objects cannot be pickled #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_descriptor_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">FD_KEY</span><span class="p">]</span><span class="o">.</span><span class="n">kp_descriptor_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_detector_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">FD_KEY</span><span class="p">]</span><span class="o">.</span><span class="n">kp_detector_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">TRANSFORMER_KEY</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">similarity_metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">SIM_METRIC_KEY</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_filter_method</span> <span class="o">=</span> <span class="n">match_filter_method</span>

    <span class="k">def</span> <span class="nf">_set_non_rigid_reg_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">non_rigid_reg_class</span><span class="p">,</span> <span class="n">non_rigid_reg_params</span><span class="p">,</span> <span class="n">reference_img_f</span><span class="p">,</span> <span class="n">qt_emitter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set non-rigid registration kwargs</span>
<span class="sd">        Keyword arguments will be passed to `serial_non_rigid.register_images`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">NAME_KEY</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                                     <span class="n">NON_RIGID_REG_CLASS_KEY</span><span class="p">:</span> <span class="n">non_rigid_reg_class</span><span class="p">,</span>
                                     <span class="n">NON_RIGID_REG_PARAMS_KEY</span><span class="p">:</span> <span class="n">non_rigid_reg_params</span><span class="p">,</span>
                                     <span class="n">REF_IMG_KEY</span><span class="p">:</span> <span class="n">reference_img_f</span><span class="p">,</span>
                                     <span class="n">QT_EMMITER_KEY</span><span class="p">:</span> <span class="n">qt_emitter</span>
                                     <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_class_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_kwargs</span><span class="p">[</span><span class="n">NON_RIGID_REG_CLASS_KEY</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">get_imgs_in_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all images in Valis.src_dir</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_path_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_dir</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_dir</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">img_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">full_path_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">get_img_type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="n">img_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">full_path_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="n">dir_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">is_round</span><span class="p">,</span> <span class="n">master_slide</span> <span class="o">=</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">determine_if_staining_round</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_round</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">master_slide</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Some formats, like .mrxs have the main file but</span>
                    <span class="c1"># data in a subdirectory with the same name</span>
                    <span class="n">matching_f</span> <span class="o">=</span> <span class="p">[</span><span class="n">ff</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">full_path_list</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">dir_name</span><span class="p">,</span> <span class="n">ff</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ff</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dir_name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">matching_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="p">:</span>
                            <span class="c1">#Make sure that file not already in list</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span>
                            <span class="n">img_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dir_name</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span><span class="si">}</span><span class="s2"> matches for </span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Can&#39;t find slide file associated with </span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_dst_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set paths to where the results will be saved.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">img_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">CONVERTED_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">PROCESSED_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_dst_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">RIGID_REG_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_dst_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">NON_RIGID_REG_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">DEFORMATION_FIELD_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">OVERLAP_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">REG_RESULTS_DATA_DIR</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_imgs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reader_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert slides to images and create dictionary of Slides.</span>

<span class="sd">        series : int, optional</span>
<span class="sd">            Slide series to be read. If None, the series with largest image will be read</span>

<span class="sd">        reader_cls : SlideReader, optional</span>
<span class="sd">            Uninstantiated SlideReader class that will convert</span>
<span class="sd">            the slide to an image, and also collect metadata.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">img_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reader_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reader_cls</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">get_slide_reader</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">)</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="n">reader_cls</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">)</span>

            <span class="n">slide_dims</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">slide_dimensions</span>
            <span class="n">levels_in_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">slide_dims</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels_in_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">levels_in_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slide_dims</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">img</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">slide2image</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>

            <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">scaling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">rescale_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>

            <span class="n">slide_obj</span> <span class="o">=</span> <span class="n">Slide</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span>
            <span class="n">img_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">img_type</span><span class="p">)</span>
            <span class="c1"># Will overwrite data if provided. Can occur if reading images, not the actual slides #</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dims_dict_wh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">matching_slide</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dims_dict_wh</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                  <span class="k">if</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">slide_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dims_dict_wh</span><span class="p">[</span><span class="n">matching_slide</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">slide_dims</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">slide_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">slide_dims</span><span class="p">]])</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_shape_rc</span> <span class="o">=</span> <span class="n">slide_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_xyu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution_xyu</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_xyu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unique_img_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">img_types</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_img_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image_type</span> <span class="o">=</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">MULTI_MODAL_NAME</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image_type</span> <span class="o">=</span> <span class="n">unique_img_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_img_max_dims</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">check_img_max_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure that all images have similar sizes.</span>

<span class="sd">        `max_image_dim_px` will be set to the maximum dimension of the</span>
<span class="sd">        smallest image if that value is less than max_image_dim_px</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">og_img_sizes_wh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">img_max_dims</span> <span class="o">=</span> <span class="n">og_img_sizes_wh</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">min_max_wh</span> <span class="o">=</span> <span class="n">img_max_dims</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">scaling_for_og_imgs</span> <span class="o">=</span> <span class="n">min_max_wh</span><span class="o">/</span><span class="n">img_max_dims</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">scaling_for_og_imgs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Smallest image is less than max_image_dim_px. parameter max_image_dim_px is being set to </span><span class="si">{</span><span class="n">min_max_wh</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span> <span class="o">=</span> <span class="n">min_max_wh</span>
            <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="c1"># Rescale images</span>
                <span class="n">scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">scaling</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span>
                <span class="k">if</span> <span class="n">scaling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span>  <span class="n">warp_tools</span><span class="o">.</span><span class="n">rescale_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;parameter max_processed_image_dim_px also being updated to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span>

    <span class="k">def</span> <span class="nf">create_original_composite_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create imaage showing how images overlap before registration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">min_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">max_r</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">max_c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">composite_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">image</span>
            <span class="n">padded_img</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">output_shape</span><span class="o">=</span><span class="n">img_obj</span><span class="o">.</span><span class="n">padded_shape_rc</span><span class="p">)</span>

            <span class="n">composite_img_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">padded_img</span>

            <span class="n">img_corners_rc</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_corners_of_image</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">warped_corners_xy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">img_corners_rc</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">min_r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">warped_corners_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">min_r</span><span class="p">)</span>
            <span class="n">max_r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">warped_corners_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">max_r</span><span class="p">)</span>
            <span class="n">min_c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">warped_corners_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">min_c</span><span class="p">)</span>
            <span class="n">max_c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">warped_corners_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">max_c</span><span class="p">)</span>

        <span class="n">composite_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">composite_img_list</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">jzazbz_cmap</span><span class="p">()</span>
        <span class="n">channel_colors</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">get_n_colors</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">composite_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">color_multichannel</span><span class="p">(</span><span class="n">composite_img</span><span class="p">,</span> <span class="n">channel_colors</span><span class="p">,</span> <span class="n">rescale_channels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">min_r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_r</span><span class="p">)</span>
        <span class="n">max_r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_r</span><span class="p">))</span>
        <span class="n">min_c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_c</span><span class="p">)</span>
        <span class="n">max_c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_c</span><span class="p">))</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">overlap_img</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">overlap_img</span>

    <span class="k">def</span> <span class="nf">measure_original_mmi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Measure Mattes mutation inormation between 2 unregistered images.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dst_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">img1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">img2</span><span class="o">.</span><span class="n">shape</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">padded_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">]):</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_padding_matrix</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dst_rc</span><span class="p">)</span>
            <span class="n">padded_img</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">dst_rc</span><span class="p">)</span>
            <span class="n">padded_img_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">padded_img</span>

        <span class="n">og_mmi</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">mattes_mi</span><span class="p">(</span><span class="n">padded_img_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">padded_img_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">og_mmi</span>

    <span class="k">def</span> <span class="nf">process_imgs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">brightfield_processing_cls</span><span class="p">,</span> <span class="n">brightfield_processing_kwargs</span><span class="p">,</span>
                     <span class="n">if_processing_cls</span><span class="p">,</span> <span class="n">if_processing_kwargs</span><span class="p">):</span>

        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Process images to make them look as similar as possible</span>

<span class="s2">        Images will also be normalized after images are processed</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        brightfield_processing_cls : ImageProcesser</span>
<span class="s2">            ImageProcesser to pre-process brightfield images to make them look as similar as possible.</span>
<span class="s2">            Should return a single channel uint8 image. The default function is</span>
<span class="s2">            </span><span class="si">{</span><span class="n">DEFAULT_BRIGHTFIELD_CLASS</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> will be used for</span>
<span class="s2">            `img_type` = </span><span class="si">{</span><span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">DEFAULT_BRIGHTFIELD_CLASS</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"></span>
<span class="s2">            is located in the preprocessing module.</span>

<span class="s2">        brightfield_processing_kwargs : dict</span>
<span class="s2">            Dictionary of keyward arguments to be passed to `ihc_processing_fxn`</span>

<span class="s2">        if_processing_fxn : ImageProcesser</span>
<span class="s2">            ImageProcesser to pre-process immunofluorescent images to make them look as similar as possible.</span>
<span class="s2">            Should return a single channel uint8 image. If None, then </span><span class="si">{</span><span class="n">DEFAULT_FLOURESCENCE_CLASS</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"></span>
<span class="s2">            will be used for `img_type` = </span><span class="si">{</span><span class="n">slide_tools</span><span class="o">.</span><span class="n">IF_NAME</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">DEFAULT_FLOURESCENCE_CLASS</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is</span>
<span class="s2">            located in the preprocessing module.</span>

<span class="s2">        if_processing_kwargs : dict</span>
<span class="s2">            Dictionary of keyward arguments to be passed to `if_processing_fxn`</span>

<span class="s2">        &quot;&quot;&quot;</span>

        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;histo_match&quot;</span><span class="p">:</span>
                <span class="n">ref_histogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_v</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">img_type</span> <span class="o">==</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span><span class="p">:</span>
                <span class="n">processing_cls</span> <span class="o">=</span> <span class="n">brightfield_processing_cls</span>
                <span class="n">processing_kwargs</span> <span class="o">=</span> <span class="n">brightfield_processing_kwargs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">processing_cls</span> <span class="o">=</span> <span class="n">if_processing_cls</span>
                <span class="n">processing_kwargs</span> <span class="o">=</span> <span class="n">if_processing_kwargs</span>

            <span class="n">levels_in_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels_in_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">levels_in_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">processor</span> <span class="o">=</span> <span class="n">processing_cls</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">src_f</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">src_f</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">series</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="o">**</span><span class="n">processing_kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># processor.process_image doesn&#39;t take kwargs</span>
                <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_image</span><span class="p">()</span>

            <span class="n">processed_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">processed_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">processed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">scaling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">processed_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">rescale_img</span><span class="p">(</span><span class="n">processed_img</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>

            <span class="n">processed_f_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_dir</span><span class="p">,</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_f</span> <span class="o">=</span> <span class="n">processed_f_out</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">processed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">io</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">processed_f_out</span><span class="p">,</span> <span class="n">processed_img</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;histo_match&quot;</span><span class="p">:</span>
                    <span class="n">img_hist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">processed_img</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
                    <span class="n">ref_histogram</span> <span class="o">+=</span> <span class="n">img_hist</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">all_v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">processed_img</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;histo_match&quot;</span><span class="p">:</span>
                <span class="n">target_stats</span> <span class="o">=</span> <span class="n">ref_histogram</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">all_v</span><span class="p">)</span>
                <span class="n">target_stats</span> <span class="o">=</span> <span class="n">all_v</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">normalize_images</span><span class="p">(</span><span class="n">target_stats</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">normalize_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalize intensity values in images</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : ndarray</span>
<span class="sd">            Target statistics used to normalize images</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Normalizing images</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_f</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;histo_match&quot;</span><span class="p">:</span>
                <span class="n">normed_img</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">match_histograms</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;img_stats&quot;</span><span class="p">:</span>
                <span class="n">normed_img</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">norm_img_stats</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="n">normed_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">normed_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">normed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">io</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_f</span><span class="p">,</span> <span class="n">normed_img</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_thumbnail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">rescale_color</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create thumbnail image to view results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">scaling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">thumbnail</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">rescale_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thumbnail</span> <span class="o">=</span> <span class="n">img</span>

        <span class="k">if</span> <span class="n">rescale_color</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">thumbnail</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">thumbnail</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">thumbnail</span>

    <span class="k">def</span> <span class="nf">draw_overlap_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create image showing the overlap of registered images</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">composite_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">img_list</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">jzazbz_cmap</span><span class="p">()</span>

        <span class="n">channel_colors</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">get_n_colors</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">composite_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">color_multichannel</span><span class="p">(</span><span class="n">composite_img</span><span class="p">,</span> <span class="n">channel_colors</span><span class="p">,</span> <span class="n">rescale_channels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">equalize_adapthist</span><span class="p">(</span><span class="n">overlap_img</span><span class="p">)</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">overlap_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">overlap_img</span>

    <span class="k">def</span> <span class="nf">get_ref_img_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create mask that covers reference image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask that covers reference image in registered images</span>
<span class="sd">        mask_bbox_xywh : tuple of int</span>
<span class="sd">            XYWH of mask in reference image</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_slide</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
        <span class="n">ref_shape_wh</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">uw_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">ref_shape_wh</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">uw_mask</span><span class="p">,</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                   <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">registered_shape_rc</span><span class="p">)</span>

        <span class="n">reg_txy</span> <span class="o">=</span> <span class="o">-</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">reg_txy</span><span class="p">,</span> <span class="o">*</span><span class="n">ref_shape_wh</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span>

    <span class="k">def</span> <span class="nf">get_all_overlap_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create mask that covers intersection of all images</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask that covers reference image in registered images</span>
<span class="sd">        mask_bbox_xywh : tuple of int</span>
<span class="sd">            XYWH of mask in reference image</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_slide</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">registered_shape_rc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">:</span>
            <span class="n">img_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">warped_img_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img_mask</span><span class="p">,</span>
                                                  <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                  <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">registered_shape_rc</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">+=</span> <span class="n">warped_img_mask</span>

        <span class="n">mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span>

    <span class="k">def</span> <span class="nf">get_null_overlap_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create mask that covers all of the image.</span>
<span class="sd">        Not really a mask</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask that covers reference image in registered images</span>
<span class="sd">        mask_bbox_xywh : tuple of int</span>
<span class="sd">            XYWH of mask in reference image</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reg_shape</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">registered_shape_rc</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">reg_shape</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reg_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reg_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span>

    <span class="k">def</span> <span class="nf">create_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create masks based on rigid registration</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">mask_dict</span><span class="p">[</span><span class="n">CROP_REF</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_img_mask</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
        <span class="n">mask_dict</span><span class="p">[</span><span class="n">CROP_OVERLAP</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_overlap_mask</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
        <span class="n">mask_dict</span><span class="p">[</span><span class="n">CROP_NONE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_null_overlap_mask</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_dict</span> <span class="o">=</span> <span class="n">mask_dict</span>

    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overlap_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get overlap mask and bounding box</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask</span>

<span class="sd">        mask_xywh : tuple</span>
<span class="sd">            XYWH for bounding box around mask</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">overlap_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">overlap_type</span> <span class="o">=</span> <span class="n">CROP_NONE</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_dict</span><span class="p">[</span><span class="n">overlap_type</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">rigid_register</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rigidly register slides</span>

<span class="sd">        Also saves thumbnails of rigidly registered images.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rigid_registrar : SerialRigidRegistrar</span>
<span class="sd">            SerialRigidRegistrar object that performed the rigid registration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rigid_registrar</span> <span class="o">=</span> <span class="n">serial_rigid</span><span class="o">.</span><span class="n">register_images</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_dir</span><span class="p">,</span>
                                                       <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">end_rigid_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_registrar</span> <span class="o">=</span> <span class="n">rigid_registrar</span>
        <span class="k">if</span> <span class="n">rigid_registrar</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Rigid registration failed&quot;</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Draw and save overlap image #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aligned_img_shape_rc</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">registered_shape_rc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_idx</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">reference_img_idx</span>

        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">src_f</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create_masks</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
        <span class="n">overlap_mask</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>

        <span class="n">overlap_mask_bbox_xywh</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">overlap_min_r</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">overlap_min_c</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">overlap_max_r</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">overlap_max_c</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">rigid_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">img_obj</span><span class="o">.</span><span class="n">registered_img</span> <span class="k">for</span> <span class="n">img_obj</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">]</span>
        <span class="n">rigid_overlap_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_overlap_img</span><span class="p">(</span><span class="n">rigid_img_list</span><span class="p">)[</span><span class="n">overlap_min_r</span><span class="p">:</span><span class="n">overlap_max_r</span><span class="p">,</span> <span class="n">overlap_min_c</span><span class="p">:</span><span class="n">overlap_max_c</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_overlap_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">rigid_overlap_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rigid_overlap_img_fout</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_rigid_overlap.png&quot;</span><span class="p">)</span>
        <span class="n">io</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">rigid_overlap_img_fout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_overlap_img</span><span class="p">)</span>

        <span class="c1"># Create original overlap image #</span>
        <span class="n">original_overlap_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_original_composite_img</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_overlap_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">original_overlap_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

        <span class="n">original_overlap_img_fout</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_original_overlap.png&quot;</span><span class="p">)</span>
        <span class="n">io</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">original_overlap_img_fout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_overlap_img</span><span class="p">)</span>


        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_dst_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span>  <span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span>  <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Update attributes in slide_obj #</span>
        <span class="n">n_digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">slide_reg_obj</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">:</span>
            <span class="n">slide_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">M</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">stack_idx</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">registered_img</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_img_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_dst_dir</span><span class="p">,</span>
                                                     <span class="nb">str</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">),</span> <span class="n">n_digits</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">get_bg_color_px_pos</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">stack_idx</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_idx</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">fixed_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">fixed_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">fixed_slide</span> <span class="o">=</span> <span class="n">fixed_slide</span>

            <span class="n">match_dict</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">match_dict</span><span class="p">[</span><span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">fixed_obj</span><span class="p">]</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev</span> <span class="o">=</span> <span class="n">match_dict</span><span class="o">.</span><span class="n">matched_kp1_xy</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev</span> <span class="o">=</span> <span class="n">match_dict</span><span class="o">.</span><span class="n">matched_kp2_xy</span>

            <span class="c1"># Get points in overlap box #</span>
            <span class="n">prev_kp_warped_for_bbox_test</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">prev_kp_in_bbox_idx</span> <span class="o">=</span> \
                <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_pts_in_bbox</span><span class="p">(</span><span class="n">prev_kp_warped_for_bbox_test</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">)</span>

            <span class="n">current_kp_warped_for_bbox_test</span> <span class="o">=</span> \
                <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">current_kp_in_bbox_idx</span> <span class="o">=</span> \
                <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_pts_in_bbox</span><span class="p">(</span><span class="n">current_kp_warped_for_bbox_test</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">)</span>

            <span class="n">matched_kp_in_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">prev_kp_in_bbox_idx</span><span class="p">,</span> <span class="n">current_kp_in_bbox_idx</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev_in_bbox</span> <span class="o">=</span>  <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev</span><span class="p">[</span><span class="n">matched_kp_in_bbox</span><span class="p">]</span> <span class="c1"># Found using processed img</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev_in_bbox</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev</span><span class="p">[</span><span class="n">matched_kp_in_bbox</span><span class="p">]</span> <span class="c1"># Found using processed img. Image at idx=i-1</span>


        <span class="c1"># Overwrite black and white processed images #</span>
        <span class="k">for</span> <span class="n">slide_name</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">slide_reg_obj</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">is_rgb</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span>

            <span class="n">warped_img</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img_to_warp</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>
            <span class="n">warped_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">warped_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>
            <span class="n">io</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_img_f</span><span class="p">,</span> <span class="n">warped_img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>

            <span class="c1"># Replace processed image with a thumbnail #</span>
            <span class="n">io</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">rigid_registrar</span>


    <span class="k">def</span> <span class="nf">non_rigid_register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Non-rigidly register slides</span>

<span class="sd">        Non-rigidly register slides after performing rigid registration.</span>
<span class="sd">        Also saves thumbnails of non-rigidly registered images and deformation</span>
<span class="sd">        fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rigid_registrar : SerialRigidRegistrar</span>
<span class="sd">            SerialRigidRegistrar object that performed the rigid registration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        non_rigid_registrar : SerialNonRigidRegistrar</span>
<span class="sd">            SerialNonRigidRegistrar object that performed serial</span>
<span class="sd">            non-rigid registration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="n">serial_non_rigid</span><span class="o">.</span><span class="n">register_images</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">rigid_registrar</span><span class="p">,</span>
                                                               <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_non_rigid_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span>  <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_dst_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_dir</span><span class="p">]:</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="n">non_rigid_registrar</span>

        <span class="c1"># Draw overlap image #</span>
        <span class="n">overlap_mask</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>
        <span class="n">overlap_mask_bbox_xywh</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">overlap_min_r</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">overlap_min_c</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">overlap_max_r</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">overlap_max_c</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">non_rigid_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">nr_img_obj</span><span class="o">.</span><span class="n">registered_img</span> <span class="k">for</span> <span class="n">nr_img_obj</span> <span class="ow">in</span> <span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">non_rigid_obj_list</span><span class="p">]</span>
        <span class="n">non_rigid_overlap_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_overlap_img</span><span class="p">(</span><span class="n">non_rigid_img_list</span><span class="p">)[</span><span class="n">overlap_min_r</span><span class="p">:</span><span class="n">overlap_max_r</span><span class="p">,</span> <span class="n">overlap_min_c</span><span class="p">:</span><span class="n">overlap_max_c</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_overlap_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">non_rigid_overlap_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

        <span class="n">overlap_img_fout</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_non_rigid_overlap.png&quot;</span><span class="p">)</span>
        <span class="n">io</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">overlap_img_fout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_overlap_img</span><span class="p">)</span>

        <span class="n">n_digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">slide_name</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">img_save_id</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">),</span> <span class="n">n_digits</span><span class="p">)</span>
            <span class="n">slide_nr_reg_obj</span> <span class="o">=</span> <span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">non_rigid_obj_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">slide_nr_reg_obj</span><span class="o">.</span><span class="n">bk_dxdy</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">slide_nr_reg_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">nr_rigid_reg_img_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_dst_dir</span><span class="p">,</span> <span class="n">img_save_id</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">is_rgb</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span><span class="o">.</span><span class="n">image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span>

            <span class="n">warped_img</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img_to_warp</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>
            <span class="n">warped_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">warped_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>
            <span class="n">io</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">nr_rigid_reg_img_f</span><span class="p">,</span> <span class="n">warped_img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>

            <span class="c1"># Save deformation grid</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">thumbnail_bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span><span class="p">)[</span><span class="n">overlap_min_r</span><span class="p">:</span><span class="n">overlap_max_r</span><span class="p">,</span> <span class="n">overlap_min_c</span><span class="p">:</span><span class="n">overlap_max_c</span><span class="p">])</span>
            <span class="n">thumbnail_bk_dxdy</span> <span class="o">*=</span> <span class="n">scaling</span>

            <span class="n">temp_draw</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>
            <span class="n">draw_img</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">temp_draw</span><span class="p">,</span>
                                        <span class="n">thumbnail_bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">temp_draw</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">draw_img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">draw_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">draw_img</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">thumbanil_deform_grid</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">color_displacement_tri_grid</span><span class="p">(</span><span class="n">thumbnail_bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                                    <span class="n">thumbnail_bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                                                    <span class="n">img</span><span class="o">=</span><span class="n">draw_img</span><span class="p">,</span>
                                                                    <span class="n">n_grid_pts</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>

            <span class="n">deform_img_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_dir</span><span class="p">,</span> <span class="n">img_save_id</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>

            <span class="n">io</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">deform_img_f</span><span class="p">,</span> <span class="n">thumbanil_deform_grid</span><span class="p">)</span>


        <span class="k">return</span> <span class="n">non_rigid_registrar</span>


    <span class="k">def</span> <span class="nf">measure_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Measure registration error</span>

<span class="sd">        Error is measured as the distance between matched features</span>
<span class="sd">        after registration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary_df : Dataframe</span>
<span class="sd">            `summary_df` contains various information about the registration.</span>

<span class="sd">            The &quot;from&quot; column is the name of the image, while the &quot;to&quot; column</span>
<span class="sd">            name of the image it was aligned to. &quot;from&quot; is analagous to &quot;moving&quot;</span>
<span class="sd">            or &quot;current&quot;, while &quot;to&quot; is analgous to &quot;fixed&quot; or &quot;previous&quot;.</span>

<span class="sd">            Columns begining with &quot;original&quot; refer to error measurements of the</span>
<span class="sd">            unregistered images. Those beginning with &quot;rigid&quot; or &quot;non_rigid&quot; refer</span>
<span class="sd">            to measurements related to rigid or non-rigid registration, respectively.</span>

<span class="sd">            Columns beginning with &quot;mean&quot; are averages of error measurements. In</span>
<span class="sd">            the case of errors based on feature distances (i.e. those ending in &quot;D&quot;),</span>
<span class="sd">            the mean is weighted by the number of feature matches between &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns endining in &quot;D&quot; indicate the median distance between matched</span>
<span class="sd">            features in &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns ending in &quot;TRE&quot; indicate the target registration error between</span>
<span class="sd">            &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns ending in &quot;mattesMI&quot; contain measurements of the Mattes mutual</span>
<span class="sd">            information between &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            &quot;processed_img_shape&quot; indicates the shape (row, column) of the processed</span>
<span class="sd">            image actually used to conduct the registration</span>

<span class="sd">            &quot;shape&quot; is the shape of the slide at full resolution</span>

<span class="sd">            &quot;aligned_shape&quot; is the shape of the registered full resolution slide</span>

<span class="sd">            &quot;physical_units&quot; are the names of the pixels physcial unit, e.g. u&#39;\u00B5m&#39;</span>

<span class="sd">            &quot;resolution&quot; is the physical unit per pixel</span>

<span class="sd">            &quot;name&quot; is the name assigned to the Valis instance</span>

<span class="sd">            &quot;rigid_time_minutes&quot; is the total number of minutes it took</span>
<span class="sd">            to convert the images and then rigidly align them.</span>

<span class="sd">            &quot;non_rigid_time_minutes&quot; is the total number of minutes it took</span>
<span class="sd">            to convert the images, and then perform rigid -&gt; non-rigid registration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">path_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_og_d</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_og_tre</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_og_mi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">all_rigid_d</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_rigid_tre</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_rigid_mi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">all_nr_d</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_nr_tre</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_nr_mi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">all_n</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">from_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">to_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">shape_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">processed_img_shape_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">unit_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">resolution_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">slide_obj_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">img_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">img_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">]</span>
        <span class="n">outshape</span> <span class="o">=</span> <span class="n">slide_obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span>
        <span class="n">overlap_mask</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">slide_obj_list</span><span class="p">)):</span>
            <span class="n">slide_name</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span>

            <span class="n">img_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span>
            <span class="n">shape_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_shape_rc</span><span class="p">)</span>
            <span class="n">processed_img_shape_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">)</span>
            <span class="n">unit_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">units</span>
            <span class="n">resolution_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span>
            <span class="n">from_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_name</span>
            <span class="n">path_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">src_f</span>
            <span class="n">rigid_img</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">registered_img</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_idx</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">prev_img_obj</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">fixed_obj</span>
            <span class="n">prev_slide_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">prev_img_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">prev_rigid_img</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">registered_img</span>
            <span class="n">to_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">name</span>

            <span class="n">prev_kp_in_slide</span> <span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev_in_bbox</span><span class="p">,</span>
                                                     <span class="n">M</span><span class="o">=</span><span class="n">prev_img_obj</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                     <span class="n">pt_level</span><span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                     <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">current_kp_in_slide</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev_in_bbox</span><span class="p">,</span>
                                                    <span class="n">M</span><span class="o">=</span><span class="n">img_obj</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                    <span class="n">pt_level</span><span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                    <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">og_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">prev_kp_in_slide</span> <span class="o">-</span> <span class="n">current_kp_in_slide</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">og_rtre</span> <span class="o">=</span> <span class="n">og_d</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">outshape</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="n">median_og_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">og_rtre</span><span class="p">)</span>
            <span class="n">og_d</span> <span class="o">*=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span>
            <span class="n">median_d_og</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">og_d</span><span class="p">)</span>

            <span class="n">og_mmi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_original_mmi</span><span class="p">(</span><span class="n">img_obj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">prev_img_obj</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
            <span class="n">all_og_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_d_og</span>
            <span class="n">all_og_tre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_og_tre</span>
            <span class="n">all_og_mi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">og_mmi</span>

            <span class="n">prev_warped_rigid</span> <span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev_in_bbox</span><span class="p">,</span>
                                                       <span class="n">M</span><span class="o">=</span><span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                       <span class="n">pt_level</span><span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                       <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">current_warped_rigid</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev_in_bbox</span><span class="p">,</span>
                                                     <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                     <span class="n">pt_level</span><span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                     <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">rigid_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">prev_warped_rigid</span> <span class="o">-</span> <span class="n">current_warped_rigid</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">rtre</span> <span class="o">=</span> <span class="n">rigid_d</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">outshape</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="n">median_rigid_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rtre</span><span class="p">)</span>
            <span class="n">rigid_d</span> <span class="o">*=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span>

            <span class="n">median_d_rigid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rigid_d</span><span class="p">)</span>
            <span class="n">rigid_mi</span> <span class="o">=</span>  <span class="n">warp_tools</span><span class="o">.</span><span class="n">mattes_mi</span><span class="p">(</span><span class="n">rigid_img</span><span class="p">,</span> <span class="n">prev_rigid_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">overlap_mask</span><span class="p">)</span>

            <span class="n">all_rigid_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_d_rigid</span>
            <span class="n">all_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rigid_d</span><span class="p">)</span>
            <span class="n">all_rigid_tre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_rigid_tre</span>
            <span class="n">all_rigid_mi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rigid_mi</span>

            <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">prev_warped_nr</span> <span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev_in_bbox</span><span class="p">,</span>
                                                        <span class="n">M</span><span class="o">=</span><span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                        <span class="n">pt_level</span><span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                        <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">current_warped_nr</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev_in_bbox</span><span class="p">,</span>
                                                      <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                      <span class="n">pt_level</span><span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                      <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">nr_d</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">prev_warped_nr</span> <span class="o">-</span> <span class="n">current_warped_nr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">nrtre</span> <span class="o">=</span> <span class="n">nr_d</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">outshape</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
                <span class="n">mean_nr_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">nrtre</span><span class="p">)</span>

                <span class="n">non_rigid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">non_rigid_obj_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span><span class="o">.</span><span class="n">registered_img</span>
                <span class="n">prev_non_rigid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">non_rigid_obj_dict</span><span class="p">[</span><span class="n">prev_img_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">registered_img</span>
                <span class="n">non_rigid_mi</span> <span class="o">=</span>  <span class="n">warp_tools</span><span class="o">.</span><span class="n">mattes_mi</span><span class="p">(</span><span class="n">non_rigid_img</span><span class="p">,</span> <span class="n">prev_non_rigid_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">overlap_mask</span><span class="p">)</span>

                <span class="n">nr_d</span> <span class="o">*=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span>
                <span class="n">median_d_nr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">nr_d</span><span class="p">)</span>
                <span class="n">all_nr_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_d_nr</span>
                <span class="n">all_nr_tre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_nr_tre</span>
                <span class="n">all_nr_mi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">non_rigid_mi</span>

        <span class="n">non_ref_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">non_ref_idx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_idx</span><span class="p">)</span>

        <span class="n">non_ref_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_n</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">]</span>
        <span class="n">mean_og_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_og_d</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>
        <span class="n">median_og_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_og_tre</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>

        <span class="n">mean_rigid_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_rigid_d</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>
        <span class="n">median_rigid_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_rigid_tre</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>

        <span class="n">rigid_min</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_rigid_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="n">path_list</span><span class="p">,</span>
            <span class="s2">&quot;from&quot;</span><span class="p">:</span><span class="n">from_list</span><span class="p">,</span>
            <span class="s2">&quot;to&quot;</span><span class="p">:</span> <span class="n">to_list</span><span class="p">,</span>
            <span class="s2">&quot;original_D&quot;</span><span class="p">:</span> <span class="n">all_og_d</span><span class="p">,</span>
            <span class="s2">&quot;original_TRE&quot;</span><span class="p">:</span> <span class="n">all_og_tre</span><span class="p">,</span>
            <span class="s2">&quot;original_mattesMI&quot;</span><span class="p">:</span> <span class="n">all_og_mi</span><span class="p">,</span>
            <span class="s2">&quot;rigid_D&quot;</span><span class="p">:</span> <span class="n">all_rigid_d</span><span class="p">,</span>
            <span class="s2">&quot;rigid_TRE&quot;</span><span class="p">:</span> <span class="n">all_rigid_tre</span><span class="p">,</span>
            <span class="s2">&quot;rigid_mattesMI&quot;</span><span class="p">:</span> <span class="n">all_rigid_mi</span><span class="p">,</span>
            <span class="s2">&quot;non_rigid_D&quot;</span><span class="p">:</span> <span class="n">all_nr_d</span><span class="p">,</span>
            <span class="s2">&quot;non_rigid_TRE&quot;</span><span class="p">:</span> <span class="n">all_rigid_tre</span><span class="p">,</span>
            <span class="s2">&quot;non_rigid_mattesMI&quot;</span><span class="p">:</span> <span class="n">all_nr_mi</span><span class="p">,</span>
            <span class="s2">&quot;processed_img_shape&quot;</span><span class="p">:</span> <span class="n">processed_img_shape_list</span><span class="p">,</span>
            <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="n">shape_list</span><span class="p">,</span>
            <span class="s2">&quot;aligned_shape&quot;</span><span class="p">:</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">outshape</span><span class="p">)]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;mean_original_D&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">mean_og_d</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;mean_rigid_D&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">mean_rigid_d</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;physical_units&quot;</span><span class="p">:</span><span class="n">unit_list</span><span class="p">,</span>
            <span class="s2">&quot;resolution&quot;</span><span class="p">:</span><span class="n">resolution_list</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;rigid_time_minutes&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="n">rigid_min</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="p">})</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mean_nr_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_nr_d</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>
            <span class="n">mean_nr_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_nr_tre</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>
            <span class="n">non_rigid_min</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_non_rigid_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span><span class="p">[</span><span class="s2">&quot;mean_non_rigid_D&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mean_nr_d</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span><span class="p">[</span><span class="s2">&quot;non_rigid_time_minutes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">non_rigid_min</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span>

<div class="viewcode-block" id="Valis.register"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">brightfield_processing_cls</span><span class="o">=</span><span class="n">DEFAULT_BRIGHTFIELD_CLASS</span><span class="p">,</span>
                 <span class="n">brightfield_processing_kwargs</span><span class="o">=</span><span class="n">DEFAULT_BRIGHTFIELD_PROCESSING_ARGS</span><span class="p">,</span>
                 <span class="n">if_processing_cls</span><span class="o">=</span><span class="n">DEFAULT_FLOURESCENCE_CLASS</span><span class="p">,</span>
                 <span class="n">if_processing_kwargs</span><span class="o">=</span><span class="n">DEFAULT_FLOURESCENCE_PROCESSING_ARGS</span><span class="p">,</span>
                 <span class="n">reader_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Register a collection of images</span>

<span class="sd">        This function will convert the slides to images, pre-process and normalize them, and</span>
<span class="sd">        then conduct rigid registration. Non-rigid registration will then be performed if the</span>
<span class="sd">        `non_rigid_registrar_cls` argument used to initialize the Valis object was not None.</span>

<span class="sd">        In addition to the objects returned, the desination directory (i.e. `dst_dir`)</span>
<span class="sd">        will contain thumbnails so that one can visualize the results: converted image</span>
<span class="sd">        thumbnails will be in &quot;images/&quot;; processed images in &quot;processed/&quot;;</span>
<span class="sd">        rigidly aligned images in &quot;rigid_registration/&quot;; non-rigidly aligned images in &quot;non_rigid_registration/&quot;;</span>
<span class="sd">        non-rigid deformation field images (i.e. warped grids colored by the direction and magntidue)</span>
<span class="sd">        of the deformation) will be in &quot;&quot;deformation_fields/&quot;. The size of these thumbnails</span>
<span class="sd">        is determined by the `thumbnail_size` argument used to initialze this object.</span>

<span class="sd">        One can get a sense of how well the registration worked by looking</span>
<span class="sd">        in the &quot;overlaps/&quot;, which shows how the images overlap before</span>
<span class="sd">        registration, after rigid registration, and after non-rigid registration. Each image</span>
<span class="sd">        is created by coloring an inverted greyscale version of the processed images, and then</span>
<span class="sd">        blending those images.</span>

<span class="sd">        The &quot;data/&quot; directory will contain a pickled copy of this registrar, which can be</span>
<span class="sd">        later be opened (unpickled) and used to warp slides and/or point data.</span>

<span class="sd">        &quot;data/&quot; will also contain the `summary_df` saved as a csv file.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        brightfield_processing_fxn : callable</span>
<span class="sd">            Function to pre-process brightfield images to make them look as similar as possible.</span>
<span class="sd">            Should return a single channel uint8 image.</span>

<span class="sd">        brightfield_processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `ihc_processing_fxn`</span>

<span class="sd">        if_processing_fxn : callable</span>
<span class="sd">            Function to pre-process immunofluorescent images to make them look as similar as possible.</span>
<span class="sd">            Should return a single channel uint8 image.</span>

<span class="sd">        if_processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `if_processing_fxn`</span>

<span class="sd">        reader_cls : SlideReader, optional</span>
<span class="sd">            Uninstantiated SlideReader class that will convert</span>
<span class="sd">            the slide to an image, and also collect metadata. If None (the default),</span>
<span class="sd">            the appropriate SlideReader will be found by `slide_io.get_slide_reader`.</span>
<span class="sd">            This option is provided in case the slides cannot be opened by a current</span>
<span class="sd">            SlideReader class. In this case, the user should create a subclass of</span>
<span class="sd">            SlideReader. See slide_io.SlideReader for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rigid_registrar : SerialRigidRegistrar</span>
<span class="sd">            SerialRigidRegistrar object that performed the rigid registration.</span>
<span class="sd">            This object can be pickled if so desired</span>

<span class="sd">        non_rigid_registrar : SerialNonRigidRegistrar</span>
<span class="sd">            SerialNonRigidRegistrar object that performed serial</span>
<span class="sd">            non-rigid registration. This object can be pickled if so desired.</span>

<span class="sd">        summary_df : Dataframe</span>
<span class="sd">            `summary_df` contains various information about the registration.</span>

<span class="sd">            The &quot;from&quot; column is the name of the image, while the &quot;to&quot; column</span>
<span class="sd">            name of the image it was aligned to. &quot;from&quot; is analagous to &quot;moving&quot;</span>
<span class="sd">            or &quot;current&quot;, while &quot;to&quot; is analgous to &quot;fixed&quot; or &quot;previous&quot;.</span>

<span class="sd">            Columns begining with &quot;original&quot; refer to error measurements of the</span>
<span class="sd">            unregistered images. Those beginning with &quot;rigid&quot; or &quot;non_rigid&quot; refer</span>
<span class="sd">            to measurements related to rigid or non-rigid registration, respectively.</span>

<span class="sd">            Columns beginning with &quot;mean&quot; are averages of error measurements. In</span>
<span class="sd">            the case of errors based on feature distances (i.e. those ending in &quot;D&quot;),</span>
<span class="sd">            the mean is weighted by the number of feature matches between &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns endining in &quot;D&quot; indicate the median distance between matched</span>
<span class="sd">            features in &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns ending in &quot;TRE&quot; indicate the target registration error between</span>
<span class="sd">            &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns ending in &quot;mattesMI&quot; contain measurements of the Mattes mutual</span>
<span class="sd">            information between &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            &quot;processed_img_shape&quot; indicates the shape (row, column) of the processed</span>
<span class="sd">            image actually used to conduct the registration</span>

<span class="sd">            &quot;shape&quot; is the shape of the slide at full resolution</span>

<span class="sd">            &quot;aligned_shape&quot; is the shape of the registered full resolution slide</span>

<span class="sd">            &quot;physical_units&quot; are the names of the pixels physcial unit, e.g. u&#39;\u00B5m&#39;</span>

<span class="sd">            &quot;resolution&quot; is the physical unit per pixel</span>

<span class="sd">            &quot;name&quot; is the name assigned to the Valis instance</span>

<span class="sd">            &quot;rigid_time_minutes&quot; is the total number of minutes it took</span>
<span class="sd">            to convert the images and then rigidly align them.</span>

<span class="sd">            &quot;non_rigid_time_minutes&quot; is the total number of minutes it took</span>
<span class="sd">            to convert the images, and then perform rigid -&gt; non-rigid registration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Converting images</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convert_imgs</span><span class="p">(</span><span class="n">series</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">,</span> <span class="n">reader_cls</span><span class="o">=</span><span class="n">reader_cls</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Processing images</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">brightfield_procsseing_fxn_str</span> <span class="o">=</span> <span class="n">brightfield_processing_cls</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">if_processing_fxn_str</span> <span class="o">=</span> <span class="n">if_processing_cls</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_imgs</span><span class="p">(</span><span class="n">brightfield_processing_cls</span><span class="p">,</span> <span class="n">brightfield_processing_kwargs</span><span class="p">,</span>
                              <span class="n">if_processing_cls</span><span class="p">,</span> <span class="n">if_processing_kwargs</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Rigid registraration</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">rigid_registrar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_register</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">rigid_registrar</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Non-rigid registraration</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_register</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Measuring error</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="n">aligned_slide_shape_rc</span>
            <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="n">aligned_slide_shape_rc</span>

            <span class="n">error_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_error</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>

            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">f_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_registrar.pickle&quot;</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">f_out</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>

            <span class="n">data_f_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_summary.csv&quot;</span><span class="p">)</span>
            <span class="n">error_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">data_f_out</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
            <span class="n">kill_jvm</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>


        <span class="k">return</span> <span class="n">rigid_registrar</span><span class="p">,</span> <span class="n">non_rigid_registrar</span><span class="p">,</span> <span class="n">error_df</span></div>

    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove objects that can&#39;t be pickled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="s2">&quot;feature_detector&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="s2">&quot;affine_optimizer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_aligned_slide_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the shape of aligned slide at the spefified level</span>
<span class="sd">        Based on shape of reference image</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span>

        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">slide_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slide_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">s_rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">slide_shape_rc</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">))</span>
        <span class="n">aligned_out_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="o">*</span><span class="n">s_rc</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">aligned_out_shape_rc</span>

<div class="viewcode-block" id="Valis.get_slide"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis.get_slide">[docs]</a>    <span class="k">def</span> <span class="nf">get_slide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get Slide</span>

<span class="sd">        Get the Slide associated with `src_f`.</span>
<span class="sd">        Slide store registration parameters and other metadata about</span>
<span class="sd">        the slide associated with `src_f`. Slide can also:</span>

<span class="sd">        * Convert the slide to a numpy array (Slide.slide2image)</span>
<span class="sd">        * Convert the slide to a pyvips.Image (Slide.slide2vips)</span>
<span class="sd">        * Warp the slide (Slide.warp_slide)</span>
<span class="sd">        * Save the warped slide as an ome.tiff (Slide.warp_and_save_slide)</span>
<span class="sd">        * Warp an image of the slide (Slide.warp_img)</span>
<span class="sd">        * Warp points (Slide.warp_xy)</span>
<span class="sd">        * Warp points in one slide to their position in another unwarped slide (Slide.warp_xy_from_to)</span>
<span class="sd">        * Access slide ome-xml (Slide.original_xml)</span>

<span class="sd">        See Slide for more details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_f : str</span>
<span class="sd">            Path to the slide</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        slide_obj : Slide</span>
<span class="sd">            Slide associated with src_f</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">slide_name</span> <span class="o">=</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">src_f</span><span class="p">)</span>
        <span class="n">slide_obj</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">slide_obj</span></div>

    <span class="nd">@valtils</span><span class="o">.</span><span class="n">deprecated_args</span><span class="p">(</span><span class="n">crop_to_overlap</span><span class="o">=</span><span class="s2">&quot;crop&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">warp_and_save_slides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dst_dir</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">,</span>
                             <span class="n">tile_wh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">):</span>

        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Warp and save all slides</span>

<span class="s2">        Each slide will be saved as an ome.tiff. The extension of each file will</span>
<span class="s2">        be changed to ome.tiff if it is not already.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        dst_dir : str</span>
<span class="s2">            Path to were the warped slides will be saved.</span>

<span class="s2">        level : int, optional</span>
<span class="s2">            Pyramid level to be warped. Default is 0, which means the highest</span>
<span class="s2">            resolution image will be warped and saved.</span>

<span class="s2">        non_rigid : bool, optional</span>
<span class="s2">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="s2">            then only a rigid transformation will be applied. Default is True</span>

<span class="s2">        crop: bool, str</span>
<span class="s2">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="s2">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="s2">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="s2">            cropped to include only areas where all images overlapped.</span>
<span class="s2">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="s2">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="s2">        interp_method : str</span>
<span class="s2">            Interpolation method used when warping slide. Default is &quot;bicubic&quot;</span>

<span class="s2">        tile_wh : int, optional</span>
<span class="s2">            Tile width and height used to save image</span>

<span class="s2">        compression : str, optional</span>
<span class="s2">            Compression method used to save ome.tiff . Default is lzw, but can also</span>
<span class="s2">            be jpeg or jp2k. See pyips for more details.</span>

<span class="s2">        &quot;&quot;&quot;</span>
        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">dst_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">dst_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.ome.tiff&quot;</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_and_save_slide</span><span class="p">(</span><span class="n">dst_f</span><span class="o">=</span><span class="n">dst_f</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">,</span>
                                          <span class="n">non_rigid</span><span class="o">=</span><span class="n">non_rigid</span><span class="p">,</span>
                                          <span class="n">crop</span><span class="o">=</span><span class="n">crop</span><span class="p">,</span>
                                          <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="n">perceputally_uniform_channel_colors</span><span class="p">,</span>
                                          <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">,</span>
                                          <span class="n">tile_wh</span><span class="o">=</span><span class="n">tile_wh</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

<div class="viewcode-block" id="Valis.warp_and_merge_slides"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis.warp_and_merge_slides">[docs]</a>    <span class="nd">@valtils</span><span class="o">.</span><span class="n">deprecated_args</span><span class="p">(</span><span class="n">crop_to_overlap</span><span class="o">=</span><span class="s2">&quot;crop&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">warp_and_merge_slides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dst_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">channel_name_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">src_f_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">drop_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tile_wh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Warp and merge registered slides</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dst_f : str, optional</span>
<span class="sd">            Path to were the warped slide will be saved. If None, then the slides will be merged</span>
<span class="sd">            but not saved.</span>

<span class="sd">        level : int, optional</span>
<span class="sd">            Pyramid level to be warped. Default is 0, which means the highest</span>
<span class="sd">            resolution image will be warped and saved.</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied. Default is True</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        channel_name_dict : dict of lists, optional.</span>
<span class="sd">            key =  slide file name, value = list of channel names for that slide. If None,</span>
<span class="sd">            the the channel names found in each slide will be used.</span>

<span class="sd">        src_f_list : list of str, optionaal</span>
<span class="sd">            List of paths to slide to be warped. If None (the default), Valis.original_img_list</span>
<span class="sd">            will be used. Otherwise, the paths to which `src_f_list` points to should</span>
<span class="sd">            be an alternative copy of the slides, such as ones that have undergone</span>
<span class="sd">            processing (e.g. stain segmentation), had a mask applied, etc...</span>

<span class="sd">        perceputally_uniform_channel_colors : bool, optional</span>
<span class="sd">            Whether or not to add perceptually uniform channel colors.</span>

<span class="sd">        drop_duplicates : bool, optional</span>
<span class="sd">            Whether or not to drop duplicate channels that might be found in multiple slides.</span>
<span class="sd">            For example, if DAPI is in multiple slides, then the only the DAPI channel in the</span>
<span class="sd">            first slide will be kept.</span>

<span class="sd">        tile_wh : int, optional</span>
<span class="sd">            Tile width and height used to save image</span>

<span class="sd">        interp_method : str</span>
<span class="sd">            Interpolation method used when warping slide. Default is &quot;bicubic&quot;</span>

<span class="sd">        compression : str</span>
<span class="sd">            Compression method used to save ome.tiff . Default is lzw, but can also</span>
<span class="sd">            be jpeg or jp2k. See pyips for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_slide : pyvips.Image</span>
<span class="sd">            Image with all channels merged. If `drop_duplicates` is True, then this</span>
<span class="sd">            will only contain unique channels.</span>

<span class="sd">        all_channel_names : list of str</span>
<span class="sd">            Name of each channel in the image</span>

<span class="sd">        ome_xml : str</span>
<span class="sd">            OME-XML string containing the slide&#39;s metadata</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">channel_name_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel_name_dict_by_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">channel_name_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">channel_name_dict</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">src_f_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">src_f_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span>

        <span class="n">all_channel_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">merged_slide</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">src_f_list</span><span class="p">:</span>
            <span class="n">slide_name</span> <span class="o">=</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">slide_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span>

            <span class="n">warped_slide</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_slide</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="n">non_rigid</span><span class="p">,</span>
                                                <span class="n">crop</span><span class="o">=</span><span class="n">crop</span><span class="p">,</span>
                                                <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">)</span>

            <span class="n">keep_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">warped_slide</span><span class="o">.</span><span class="n">bands</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">channel_name_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slide_channel_names</span> <span class="o">=</span> <span class="n">channel_name_dict_by_name</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">drop_duplicates</span><span class="p">:</span>
                    <span class="n">keep_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span>  <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slide_channel_names</span><span class="p">))</span> <span class="k">if</span>
                                <span class="n">slide_channel_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_channel_names</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">slide_channel_names</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">channel_names</span>
                <span class="n">slide_channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="s2">&quot; (&quot;</span> <span class="o">+</span> <span class="n">slide_name</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span>  <span class="n">slide_channel_names</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">drop_duplicates</span> <span class="ow">and</span> <span class="n">warped_slide</span><span class="o">.</span><span class="n">bands</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_idx</span><span class="p">):</span>
                <span class="n">keep_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">warped_slide</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span>
                <span class="n">slide_channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">slide_channel_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_channels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">warped_slide</span> <span class="o">=</span> <span class="n">keep_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warped_slide</span> <span class="o">=</span> <span class="n">keep_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bandjoin</span><span class="p">(</span><span class="n">keep_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;merging </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">slide_channel_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">merged_slide</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">merged_slide</span> <span class="o">=</span> <span class="n">warped_slide</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_slide</span> <span class="o">=</span> <span class="n">merged_slide</span><span class="o">.</span><span class="n">bandjoin</span><span class="p">(</span><span class="n">warped_slide</span><span class="p">)</span>

            <span class="n">all_channel_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">slide_channel_names</span><span class="p">)</span>


        <span class="n">px_phys_size</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">scale_physical_size</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">bf_dtype</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">vips2bf_dtype</span><span class="p">(</span><span class="n">merged_slide</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="n">out_xyczt</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">get_shape_xyzct</span><span class="p">((</span><span class="n">merged_slide</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">merged_slide</span><span class="o">.</span><span class="n">height</span><span class="p">),</span> <span class="n">merged_slide</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span>
        <span class="n">ome_xml_obj</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">create_ome_xml</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">,</span> <span class="n">bf_dtype</span><span class="p">,</span> <span class="n">is_rgb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">pixel_physical_size_xyu</span><span class="o">=</span><span class="n">px_phys_size</span><span class="p">,</span>
                                              <span class="n">channel_names</span><span class="o">=</span><span class="n">all_channel_names</span><span class="p">,</span>
                                              <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="n">perceputally_uniform_channel_colors</span><span class="p">)</span>
        <span class="n">ome_xml</span> <span class="o">=</span> <span class="n">ome_xml_obj</span><span class="o">.</span><span class="n">to_xml</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">dst_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dst_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dst_f</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">dst_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tile_wh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tile_wh</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">optimal_tile_wh</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">down_sampling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">/</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">tile_wh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tile_wh</span><span class="o">*</span><span class="n">down_sampling</span><span class="p">))</span>
                    <span class="n">tile_wh</span> <span class="o">=</span> <span class="n">tile_wh</span> <span class="o">-</span> <span class="p">(</span><span class="n">tile_wh</span> <span class="o">%</span> <span class="mi">16</span><span class="p">)</span>  <span class="c1"># Tile shape must be multiple of 16</span>
                    <span class="k">if</span> <span class="n">tile_wh</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
                        <span class="n">tile_wh</span> <span class="o">=</span> <span class="mi">16</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tile_wh</span><span class="p">):</span>
                        <span class="n">tile_wh</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">slide_io</span><span class="o">.</span><span class="n">save_ome_tiff</span><span class="p">(</span><span class="n">merged_slide</span><span class="p">,</span> <span class="n">dst_f</span><span class="o">=</span><span class="n">dst_f</span><span class="p">,</span>
                                   <span class="n">ome_xml</span><span class="o">=</span><span class="n">ome_xml</span><span class="p">,</span><span class="n">tile_wh</span><span class="o">=</span><span class="n">tile_wh</span><span class="p">,</span>
                                   <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_slide</span><span class="p">,</span> <span class="n">all_channel_names</span><span class="p">,</span> <span class="n">ome_xml</span></div></div>

</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Chandler Gatenbee.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>